<HTML>
<head><title>Chapter 3   Syntactic Analysis of Visual Sentences</title></head>
<center><H1>Chapter 3   Syntactic Analysis of Visual Sentences</H2></center>
<BODY bgcolor=white>
<!--. sp 2-->
<BR>
<BR>
<!--. NH -->
<H2>
1.
A Visual Language Compiler
<!--. PP -->
</H2>
<P>
In Chapter 1, we introduced elements of the
formal theory of visual languages.  The main notion can be stated as follows:
<!--. ul -->
<i>
a visual language can be designed, by specifying a system of generalized icons.
</i>
<!--. PP -->
</P>
<P>
In this section and the following sections, we describe the design of a visual language compiler, called the
<!--. ul -->
<i>
SIL-ICON Compiler
</i>
(Syntactic, Interactive, Learning, ICON-oriented-system Compiler), which
is a software system for the specification, interpretation,
prototyping, and generation of icon-oriented systems.
The SIL-ICON Compiler has the following characteristics:
<!--. PP -->
</P>
<P>
<!--. ul -->
<i>
Syntactic Specification:
</i>
It uses a formal grammar G as a specification of iconic systems.
<!--. PP -->
</P>
<P>
<!--. ul -->
<i>
Interactive Usage:
</i>
It accepts user's specifications interactively.  The
user can access icons defined in the Icon Dictionary (ID),
and use operators in the Operator Dictionary (OD), to
create any icon in the icon world.
<!--. PP -->
</P>
<P>
<!--. ul -->
<i>
Learning Capabilities:
</i>
The user can modify ID, OD
and G, to expand or specialize the domain of applications.
<!--. PP -->
</P>
<P>
Another way of describing our approach, is that
the SIL-ICON Compiler accepts
<!--. ul -->
<i>
Symbolic Images
</i>
and
<!--. ul -->
<i>
Logical ICONs
</i>
as inputs, to allow the user to design a visual language or an icon-oriented user interface.
<!--. PP -->
</P>
<P>
The system diagram of the SIL-ICON Compiler is illustrated in Figure 1.8.
It includes the following parts:
<!--. IP G-->
</P>
<UL>
<LI>
<b>G</b><!--. ul -->
<i>
Icon System G
</i>
is a formal, syntactic specification of the iconic system.
<!--. IP ID-->
<LI>
<b>ID</b><!--. ul -->
<i>
Icon Dictionary
</i>
is a database corresponding to a set of elementary icons.
<!--. IP OD-->
<LI>
<b>OD</b><!--. ul -->
<i>
Operator Dictionary
</i>
is a set of generic operators which can be applied to icons to create new complex icons.
<!--. IP ETAG-->
<LI>
<b>ETAG</b><!--. ul -->
<i>
  Extended Task Action Grammar
</i>
provides a formal method for describing the user's conceptualization about
tasks to be performed (This part will not be discussed in this chapter).
<!--. IP ICIN-->
<LI>
<b>ICIN</b><!--. ul -->
<i>
Icon Interpreter
</i>
is the heart of the system.
An input iconic sentence (visual sentence) s, which is a spatial
arrangement of icons (i.e. a complex icon in the icon world), is interpreted by the
Icon Interpreter to arrive at a visual concept Vs.
The Icon Interpreter may be domain-specific, so that
it will perform the specific task corresponding to the visual concept.
On the other hand, a general-purpose Icon Interpreter should have a formal
knowledge structure in its knowledge-base.
The extended task grammar ETAG specifies a user's conceptualization
of an application domain, and
the correspondence between visual concepts and corresponding tasks [TAUBER86, 87].
Therefore, with the formal specification
(G, ID, OD, ETAG),
the Icon Interpreter can simulate an icon-oriented user interface.
<!--. GS -->
<p>
<!-- <img src="sk2fig/icon.sys.fig1.gif"> -->
</p>
<!--. GE -->
<!--. ce -->
<center><img src="sk1fig/fig18.gif" width=600></center>
<center>Figure 1.8:    The System Diagram of SIL-ICON Compiler</center>
<!--. sp -->
<BR>
<BR>
<!--. PP -->
</UL>
<P>
As a compiler, the SIL-ICON Compiler accepts (G, ID, OD), the user's formal specification of
an icon-oriented system as its input, then generates the 
<!--. ul -->
<i>
realized
</i>
<!--. ul -->
<i>
icon-oriented system
</i>
as its output.
<!--. PP -->
</P>
<P>
Let B denote the set of all elementary icons of an iconic system G.
Let OD denote the set of operators.  Then an
<!--. ul -->
<i>
icon world
</i>
is formally defined as the closure of (OD,B), i.e., all the
composite icons constructed from B using operators from OD.
An icon world can theoretically have
infinitely many icons, even though most of them will not be useful for a specific application domain.
An icon set selected by the user for an application domain is a subset of icon world,
which is called an
<!--. I -->
<I>
icon-oriented system.
<!--. PP -->
</P>
<P>
Therefore, an icon-oriented system is an application-oriented subset of
its icon world.
Each icon in an iconic system is defined, or characterized, by
its semantic descriptions.
Such descriptions can be formalized as the
<!--. I -->
</I><I>
evaluation rules
<!--. R -->
</I>
associated with the icon rules.
The icon set with evaluation rules, ER, is defined as,
<!--. Ne -->
<!--. EQ \*(SN-->
<PRE>
<img src=sk2fig/chang-eqn.1.gif>
<!--
ER~=~&quot;{&quot;~(~x,~X sub m ,~X sub i ,~e sub x~)~:~~~x~::=(X sub m ,X sub i )~~R~&quot;}&quot;
-->
</PRE>
<!--. EN -->
where e<sub>x</sub> is the evaluation rule for icon x.
The evaluation rules are names of executable procedures.
The user can provide the executable procedures, in which case
these procedures will be used as the evaluation rules.  If
such procedures are not provided, then the SIL-ICON Compiler will perform
icon interpretation according to (G, ID, OD).
<!--. sp 3-->
<BR>
<BR>
<!--. NH -->
</P>
<H2>
2.
The Icon Dictionary ID
<!--. PP -->
</H2>
<P>
An icon x(Xi,Xm) in its external representation
is stored in the icon dictionary ID.  The name `x' is an inherited or arbitrarily assigned
name of an icon by which a specification (Xi,Xm) of the icon can be found in ID.
<p>
<!--. NH 2-->
</P>
<H2>
2.1.
Specification of Physical Part of an Icon
<!--. PP -->
</H2>
<P>
An icon image can be a picture,
a sketch, or a symbol.  It can be regarded as composed from different 
primitive patterns. Therefore, the physical part of an icon can be described by
a picture grammar. For example, the following picture grammar PG is defined for the description of the
Heidelberg Icon Set (see Appendix 1).
<!--. DS -->
<PRE>
PG(V, T, Y, P)    where
<p>
	V = {Y, &lt;primitive&gt;, &lt;i-op&gt;}
		is a set of nonterminals;
	T = {gap, rectangle,...,cross, (, ), +, &amp;. ^}
		is a set of terminals;
	Y is the starting symbol;
	P is a set of rules:
		Y --&gt; ( Y  &lt;i-op&gt;  Y ) |  &lt;primitive&gt;
		&lt;primitive&gt; --&gt; gap | rectangle |
				d_rectangle | square | d_square |
				diagonal | r_arrow | d_arrow |
				u_arrow | b_arrow | cross 
                &lt;i-op&gt; --&gt; + | &amp; | ^ 
<!--. DE -->
</PRE>
<!--. sp -->
<BR>
<BR>
<!--. PP -->
</P>
<P>
In the picture grammar PG, the syntactic category &lt;primitive&gt; stands for different
primitive patterns, and &lt;i-op&gt; stands for spatial image operators
such as &amp; (spatial overlay), + (horizontal concatenation),
and ^ (vertical concatenation).
<!--. PP -->
</P>
<P>
With this picture grammar PG, the icon for this string taken from the Heidelberg Icon Set
<!--. PS < icon/icon.sys.picfig/inter.cstring-->
<p><img src=sk2fig/inter.cstring.gif><p>
is described as 
<!--. I -->
<I>
(square + (square + square ))
<!--. R -->
</I>
or
<!--. I -->
<I>
((square + square) + square).
<!--. R -->
</I>
<!--. sp -->
<BR>
<BR>
<!--. NH 2-->
</P>
<H2>
2.2.
Specification of Logical Part of an Icon
<!--. PP -->
</H2>
<P>
For the specification of the logical part of an icon, a
<!--. I -->
<I>
conceptual representation
<!--. R -->
</I>
is used.  In this chapter, the specification of the meaning of
the example icons defines the conceptual knowledge conveyed by these icons to
the user.
However, this specification also can be regarded as a high level conceptual description
of the tasks performed by the icon-oriented system.
For the specification of concepts and their conceptual structure, we will use
conceptual graphs [SOWA84].  A
<!--. I -->
<I>
conceptual graph CG
<!--. R -->
</I>
is a finite, connected, bipartite graph.  One node type represents concepts,
the other conceptual relations.  A conceptual relation has one or
more arcs linked to concepts so a relation can be monadic, dyadic, ....,
or n-adic.  The smallest CG is a single concept, but a single relation alone
may not form a CG.  In this chapter, we use the following notation to represent a CG:
<!--. sp -->
<BR>
<BR>
<!--. KS -->
<BR>
<!--. nf -->
<pre>
<BR>
	[CONCEPT] -&gt; (RELATION) -&gt; [CONCEPT] , or
<BR>
	[CONCEPT] -- (RELATION) -&gt; [CONCEPT]
<BR>
		(RELATION) -&gt; [CONCEPT]  (for multiple arcs)
<BR>
</pre>
<!--. sp -->
<BR>
<BR>
<!--. fi -->
<BR>
<!--. KE -->
<BR>
The CG used in the chapter is a nested graph: each concept can be
again represented by a CG.  Therefore a complex CG can be represented by a top level graph and
subgraphs to be used to replace concepts in the graphs.
<!--. PP -->
</P>
<P>
A concept is denoted by [] and the name used inside the brackets is 
the 
<!--. I -->
<I>
type
<!--. R -->
</I>
of the concept. For example, [ICON] is a concept representing an unspecified individual
of type ICON,  i.e., a
<!--. I -->
<I>
generic concept.
<!--. R -->
</I>
[ICON:*] is an equivalent notation, where * is called the 
<I>generic marker</I>. [ICON:*x] stands for an arbitrary individual
of type ICON.
An <I>individual marker</I> is used when a particular individual of a
concept is denoted.  For example, [ICON: #1] is an
<!--. I -->
<I>
individual concept.
<!--. R -->
</I>
<!--. PP -->
</P>
<P>
For an icon world, we define S<sub>C</sub> as the set
of basic concepts, S<sub>R</sub> as the set of conceptual relations, and
I as the set of individual markers. 
For each concept
c in S<sub>C</sub>, the following functions are defined:
<!--. sp -->
<BR>
<BR>
REFERENT(c) returns either the generic marker * or an individual marker #n in I, and
<!--. sp -->
<BR>
<BR>
TYPE(c) returns a type label t.
<!--. PP -->
</P>
<P>
Types are related together as specified by a 
<!--. I -->
<I>
type hierarchy
<!--. R -->
</I>
which is defined by a partial ordering [SOWA84].
In this chapter, the conceptual framework used
for the example icons is defined by the types OBJECT, PLACE, PATH, STATE,
and EVENT.  Subtypes of OBJECT are, for example, LINE and STRING.  Subtypes 
of PLACE include ROW, and subtypes of EVENT include INSERT_LINE.  Figure 1.9 illustrates this 
hierarchy of types.
<!--. sp -->
<BR>
<BR>
<!--. GS -->
<p>
<!-- <img src=sk2fig/icon.sys.fig2.a.gif> -->
</P>
<!--. GE -->
<!--. ce -->
<center><img src="sk1fig/fig19.gif" width=600></center>
<center>Figure 1.9:       Type Hierarchy of the Heidelberg Icon Set</center>
<!--. sp -->
<BR>
<BR>
<!--. PP -->
</P>
<P>
Sometimes we will specify a concept and its supertype.  For example, [OBJECT = LINE] is
a generic concept [LINE] which has [OBJECT] as its
supertype.
<!--. sp -->
<BR>
<BR>
<!--. NH 2-->
</P>
<H2>
2.3.
Structure of ID 
<!--. PP -->
</H2>
<P>
The Icon Dictionary ID is a database consisting of elementary icons. Each entry of
ID stores an icon and is defined in the following format:
<p>
<pre>
    ENTRY:=NAME,SKETCH{;SKETCH},DESC,TYPE,[EVAL],
		CG{;TYPE,[EVAL],CG},[ATTRIBUTES].
</pre>
</P>
where the braces {} denote repetitions of an item. The meaning of the items
is as follows:
<!--. IP "* NAME ----"-->
</P>
<UL>
<LI>
<b>* NAME ----</b>unique identifier for an icon or a type label.
<!--. IP "* SKETCH --"-->
<LI>
<b>* SKETCH --</b>a pattern string described by a picture grammar.
<!--. IP "* DESC ----"-->
<LI>
<b>* DESC ----</b>a concise description of meaning of an icon for inclusion in the manual.
<!--. IP "* TYPE ----"-->
<LI>
<b>* TYPE ----</b>a type label indicating object icon, process icon, etc.
<!--. IP "* EVAL ----"-->
<LI>
<b>* EVAL ----</b>an optional item used by the Icon Interpreter to
generate the action part of this icon, typically a procedure name.
<!--. IP "* CG ------"-->
<LI>
<b>* CG ------</b>a conceptual description of icon semantics generated by 
conceptual analysis.
<!--. IP "* ATTRIBUTES ---"-->
<LI>
<b>* ATTRIBUTES ---</b>optional attributes of an icon.
<!--. PP -->
</UL>
<P>
In the following example of an icon-oriented text editor using the Heidelberg Icon Set,
the optional items EVAL and ATTRIBUTES are not used.
A formal grammar IG describing ID entries is given in Appendix 3.
<!--. NH 2-->
</P>
<H2>
2.4.
Examples for the Definition of ID
<!--. PP -->
</H2>
<P>
In order to illustrate how the SIL-ICON Compiler works, 
the Heidelberg Icon Set (HD Icon Set) will be used as an example.
From this set, we will consider five simple text editing
operations:
<!--. I -->
<I>
insert line, insert string, delete string, replace string, 
<!--. R -->
</I>
and <I>move string</I>.
The Heidelberg Icon Set was constructed for psychological
experiments on visually supported human concept building in text editing.
The icons are used as command symbols for a menu (instead of verbal symbols)
in a special text editor [KEPPEL&amp;ROHR84], [ROHR&amp;KEPPEL84],
[ROHR86].
<!--. PP -->
</P>
<P>
Figure 1.10 shows the five HD icons: 
<!--. I -->
<I>
insert line, insert string, delete string, move string,
<!--. R -->
</I>
and <I>replace string</I>.
<!--. KF -->
<BR>
<!--. PS < icon/icon.sys.picfig/vis.6-->
<p><img src=sk2fig/vis.6.gif><br>
<!--. ce -->
<p><center>Figure 1.10: Icons from the Heidelberg Icon Set</center>
<!--. sp -->
<BR>
<BR>
<!--. KE -->
<BR>
<!--. PP -->
</P>
<P>
Each of the five HD icons is built from some
elementary icons. The icon for
<!--. I -->
<I>
insert line,
<!--. R -->
</I>
for example, consists of a horizontal right pointing arrow, an icon for a
line, and an icon indicating a line marked as <I>that line</I>. The meaning
of this complex icon is the insertion of a line to the position before <I>that</I> <I>line</I>.
<!--. PP -->
</P>
<P>
Only elementary icons are stored in ID.  Therefore, in ID we do not have the five HD icons. 
We will define the elementary icons the HD icons are built from: the rectangle, the
square, the filled rectangle, the filled square, the cross, the
diagonal, the arrow, and the arrow with a box.  For all these icons, the
physical part is defined in the SKETCH item, in terms of the grammar PG.
The logical part is described by a CG.
<!--. PP -->
</P>
<P>
As elementary object icons we have icons for line and character. 
A rectangle symbolizes the former, and a square the latter. 
The diagonal line signifies a place where an indicated object
may be exchanged by another object.
Arrow and cross are elementary process icons.  The arrow signifies 
a movement of an object to a place.  The cross signifies the deletion of an
object.
<!--. PP -->
</P>
<P>
The <I>replace icon</I> signifies the replacement of a string by
another string.  The elementary icons used in the replacement icon are:
the arrow, the diagonal, and squares.  The meaning expressed by these
elementary icons is as follows:
<!--. IP --->
</P>
<UL>
<LI>
<b>-</b>A string composed of characters (signified by a sequence
of three squares) is moved to 
<!--. IP --->
<LI>
<b>-</b>a place defined by a marked string
(signified by filled squares and normal squares) which is ready for
<!--. IP --->
<LI>
<b>-</b>exchange (signified by the diagonal).
<!--. PP -->
</UL>
<P>
The following two examples of ID entries illustrate how the ID 
is described. A full description of the five complex HD icons,
the intermediary icons, and the elementary icons, is given in Appendix 1.
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.char-->
<img src=sk2fig/basic.char.gif>
<!--. nf -->
<BR>
CHARACTER, square,&quot;a character&quot;, OBJECT,,
<BR>
[OBJECT = CHARACTER].
<BR>
<!--. KE -->
<!--. fi -->
<!--. sp -->
<BR>
<!--. PP -->
</P>
<P>
This entry describes the elementary icon signifying an arbitrary character.
The next icon describes the arrow as signifying movements of new objects to 
places.
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.arrows-->
<img src=sk2fig/basic.arrows.gif>
<!--. nf -->
<BR>
ARROW, d_arrow; u_arrow; r_arrow,
<BR>
	&quot;movement of new objects&quot;, EVENT,,
<BR>
[EVENT = INSERTION] -- (THEME) -&gt; [OBJECT]
<BR>
	(event.GO) -&gt; [PATH : P.1] -&gt; (place.TO) -&gt; [PLACE].
<BR>
<!--. KE -->
<BR>
<!--. fi -->
<BR>
<!--. PP -->
</P>
<P>
The meaning of an elementary icon is described by a conceptual graph (CG). 
The definition of an arrow shows that different icon images can sometimes signify the same
meaning.  We also can have different meanings for the same icon image.  
This is the problem of icon purity, which was discussed in Section 8.
<!--. PP -->
</P>
<P>
The five HD icons we consider are built from the elementary icons defined in ID.
The synthesis of these five icons is based upon operators in OD, which will be explained in the next section.
<!--. sp 3-->
<BR>
<BR>
<!--. NH -->
</P>
<H2>
3.
The Operator Dictionary OD
<!--. PP -->
</H2>
<P>
<!--. ls 2     TWO-->
Iconic operators are special icons which carry certain meanings based on actions to
be performed.  They may be represented by conceptual graphs.
However, it is more convenient to represent them directly
as procedures. The basic actions performed by iconic operators include:  
<p>
<pre>
    - constructing the image of a resultant icon;
    - constructing the conceptual graph of a resultant icon;
    - synthesizing descriptions;
    - determining the type label of resultant icon; 
    - determining the common attributes of icons; and
    - optionally performing evaluation.
</pre>
<!--. PP -->
</P>
<P>
The following functions perform various transformations and mappings on
an iconic representation.  These functions are useful, when we
define the iconic operators.
<p>
<pre>
    - find(x)  returns the specification (Xi,Xm) of icon x.
    - flp(x)   returns the logical part Xm of icon x.
    - fpp(x)   returns the physical part Xi of icon x.
    - pmatch(Xi) returns an icon name x whose icon image is Xi.
    - lmatch(Xm) returns an icon name x whose meaning is Xm.
    - mat(Xm)   returns Xi of icon x (materialization).
    - dmat(Xi)  returns Xm of icon x (dematerialization).
</pre>
<p>
<!--. PP -->
</P>
<P>
We now describe the most important operations to be performed by the iconic
operators.
<!--. PP -->
</P>
<P>
The following procedure constructs the image (physical part) of a resultant
icon from input icons x and y, using image operator i-op.
<p>
<pre>
   procedure  ppart(x, y, i-op)
     icon x,y; 
     char i-op; /* i-op is an image operator such as '*' , '+' or '^' */  
     begin
        sketch = image-operation( i-op, fpp(x), fpp(y) );
        draw(sketch); /* draw the sketch on screen */
     end;
</pre>
<p>
<!--. PP -->
</P>
<P>
In the above procedure, i-op corresponds to the image operator i-op in the picture grammar.
The procedure draw(sketch) parses the pattern string using the picture grammar and draws the sketch.
<!--. PP -->
</P>
<P>
The following procedure constructs the meaning (logical part) of a resultant icon as a new conceptual graph, from input icons x and y.
<p>
<pre>
    procedure  lpart(x, y)
      icon x, y;
      begin
        restrict (x, y);
        join(x, y);
        simplify(x, y);
      end;
</pre>
<!--. PP -->
</P>
<P>
There are four generic procedures
to perform operations upon the conceptual graphs:
copy, restrict, join and simplify [SOWA84].
The generic procedures are explained below.
In what follows, u and v are input CGs, and w is the resultant CG.
<p>
      copy(u): The CG w is a copy of another CG u.
<!--. br -->
<BR>
<pre>
restrict(u,v): For any common concept c in CG u and CG v, type(c) is replaced by its 
                  subtype.  If c is generic, its referent is changed to an individual
                  marker. These changes are permitted only if referent(c) conforms
                  to type(c) before and after the changes.
    join(u,v): If a concept c in CG u is identical to a concept d in CG v, then
                  a new CG w is constructed by deleting d and linking c to 
                  all conceptual relations (arcs) that were previously linked to d.
  simplify(u): If conceptual relations r and s in CG u are identical,
                  then one of them is deleted from u together with all the 
                  conceptual relations (arcs) previously linked to it.
</pre>
<p>
<!--. PP -->
</P>
<P>
To illustrate how we define iconic operators, procedures for the iconic operators VER and HOR are described below, where
VER corresponds to the image operator '^', and HOR corresponds to the image operator '+'.
<p>
<!--. ls 1-->
<pre>
procedure ver(x,y)
 icon x,y;
  begin 
   ppart(x, y);
   prep(x,y,&quot;VER&quot;);
   lpart(x, y);
  end;
</pre>
<p>
<pre>
procedure hor(x,y)
 icon x,y;
  begin 
   ppart(x, y);
   prep(x,y,&quot;HOR&quot;);
   lpart(x, y);
  end;
</pre>
<p>
<!--. ls 2     TWO-->
<!--. PP -->
</P>
<P>
In the above, the procedure ppart(x,y) constructs the physical image of an icon, and the procedure prep(x,y,op) synthesizes icon descriptions,
determines type label of resultant icon, determines the common attributes
of icons, and performs any domain-specific evaluation.  If the conceptual
graph of an icon has multiple sub-entries (i.e. the icon is semantically
ambiguous), prep(x,y,op) may also have domain-specific rules for
selecting a unique sub-entry (i.e. it disambiguates the icon meaning).
Finally, the procedure lpart(x,y) constructs the logical meaning of an icon.
<!--. PP -->
</P>
<P>
The above described procedures serve as examples illustrating iconic operators.
An iconic operator can be thought of as an imageless icon, that is,
the physical part of such an icon is null.
An iconic operator is used to represent certain relationships
between icons.  These relationships could be either
<!--. I -->
<I>
physical relationships
<!--. R -->
</I>
or
<!--. I -->
<I>
logical relationships,
<!--. R -->
</I>
or both.
At the expense of clarity, a procedure implementing an iconic operator
can also be represented by a conceptual graph.
For example, the iconic operator HOR can be represented by a CG with formal parameters x and y:
<!--. KS -->
<BR>
<!--. ls 1-->
<!--. nf -->
<BR>
<p>
<pre>
    x,y [HOR]---
<BR>
             (PHYSICALPART)---&gt;[HORi]---
<BR>
                                  (L-PARM)---&gt;[ICON:x]
<BR>
                                  (R-PARM)---&gt;[ICON:y]
<BR>
             (LOGICALPART)---&gt;[HORm]---
<BR>
                                  (L-PARM)---&gt;[ICON:x]
<BR>
                                  (R-PARM)---&gt;[ICON:y]
<BR>
<!--. KE -->
<BR>
<!--. ls 2     TWO-->
<!--. fi -->
<BR>
<!--. sp 2-->
<BR>
<BR>
<!--. NH -->
</pre>
</P>
<H2>
4.
An Example
<!--. PP -->
</H2>
<P>
To illustrate how the Icon Interpreter works, an example of the semantic analysis of a complex icon will be presented.
The following icon rule set G1 describes
a part of the Heibelberg icon set (see Appendix 2 for other icon rules of the 
HD Icon Set):
 
<pre>
<!--. nf -->
<BR>
<!--. na -->
    G1:
<BR>
	Insert_line ::= (	{HORm, Right_arrow, On_row},
<BR>
					{HORi, Right_arrow, On_row},
<BR>
					&quot;Insert_line&quot; );
<BR>
<p>
	Right_arrow ::= ( ARROW, r_arrow, &quot;Generic_Arrow&quot; );
<BR>
<p>
	On_row ::= (	{VERm, Line, Gap, Marked_line},
<BR>
					{VERi, Line, Gap, Marked_line},
<BR>
					nil );
<BR>
<p>
	Line ::= ( LINE, rectangle, nil );
<BR>
<p>
	Marked_line ::= ( MARKED_LINE, d_rectangle,
<BR>
		&quot;Line_Pointer&quot; );
<BR>
<p>
	Gap ::= ( GAP, gap, nil );
</pre>
<BR>
<!--. fi -->
<BR>
<!--. ad -->
<p>
<!--. PP -->
</P>
<P>
Since the icons ARROW, LINE, MARKED_LINE are all elementary icons,
the Icon Interpreter can obtain the descriptions of the elementary icons from ID
while it parses an input iconic sentence using G1.  At the same time the structure
of the complex icon in question also can be determined. 
<!--. PP -->
</P>
<P>
In the following, we describe how the iconic operators HOR and VER can be applied to produce
the icon INSERT_LINE. In order to produce INSERT_LINE,
the complex icon ON_ROW is to be constructed first.
The construction of the image part of a complex icon using HORi 
(corresponding to the spatial operator +) or VERi (corresponding to the 
spatial operator ^) is straight forward.
Therefore, we will only demonstrate the construction of the meaning 
part of the ON_ROW icon.
<!--. PP -->
</P>
<P>
For the production of the conceptual graph for ON_ROW, we merge the 
involved CGs at those nodes
where the corresponding concepts in both CGs satisfy matching conditions as defined
by the type hierarchy (see Section 11). Given the iconic sentence
&quot;VER, LINE, GAP, MARKED_LINE&quot;, we construct the parsed expression
VER(LINE,VER( GAP,MARKED_LINE)), where the logical operator VER combines 
icon LINE with the resultant icon of GAP and MARKED_LINE to form 
the icon ON_ROW.
<!--. PP -->
</P>
<P>
First we consider the operation VER (GAP, MARKED_LINE). 
As we see in Appendix 1.1, GAP is a complex icon which defines a subtype of
the concept [PLACE] defined by the place.FUNCTION BEFORE and an unspecified
subtype of [OBJECT].
Now let us take (1), the CG description of the icon GAP, and (2),
the CG description for icon MARKED_LINE, as an example to 
illustrate the merging of CGs.
It should be noted that [LINE = MARKED-LINE] is the only [OBJECT] 
which may be used for the definition
of the subtype [PLACE = ROW] to the type [PLACE = BETWEEN].
<p>
<pre>
                    [PLACE = BETWEEN] -&gt; (BEFORE) -&gt; [OBJECT]         --- (1) 
     
                    [OBJECT = LINE = MARKED-LINE]                     --- (2)
</pre>
<!--. PP -->
</P>
<P>
As we mentioned in Section 11, the iconic operator recognizes the equivalence
among the concepts in both CGs so that equivalent concepts can be joined together.
In the above example, the concept [OBJECT = LINE = MARKED-LINE] in  icon 
LINE can be joined with concept [OBJECT] in icon GAP, and the result is: 
<p>
<pre>
          [PLACE = ROW] -&gt; (BEFORE) -&gt; [OBJECT = LINE = MARKED-LINE]    --- (3)
</pre>
<!--. LP -->
</P>
<P>
Then the operator combines the CG (3) with the CG for LINE which is
<p>
                             [OBJECT = LINE]                           --- (4)
<!--. LP -->
</P>
<P>
Since (4) does not restrict (3), with (3) 
we have obtained the final CG for ON_ROW.
<!--. PP -->
</P>
<P>
Similarily, the CG description of icon INSERT_LINE can be derived from the
complex icon ON_ROW and the icon ARROW. The icon INSERT_LINE is
produced by HOR(ARROW, ON_ROW). Its CG will result from joining
the conceptual graph for ARROW which is
<p>
<pre>
     [EVENT = INSERTION] -- (THEME) -&gt; [OBJECT]
                            (event.GO) -&gt; [PATH =P.1] -&gt; (path.TO) -&gt; [PLACE]
</pre>
<p>
with the conceptual graphs 
<p>
                   [OBJECT = LINE]  and [PLACE = ROW].
<p>
<!--. LP -->
</P>
<P>
The final CG for INSERT_LINE is then
<p>
<pre>
    [EVENT = INSERT_LINE] -- (THEME) -&gt; [OBJECT = LINE]
                             (event.GO) -&gt; [PATH = P.1.1] -&gt; (path.TO) -&gt; [PLACE = ROW]
</pre>
<p>
<!--. PP -->
</P>
<P>
To facilitate human understanding, the above CG can be translated into a description in
natural language.
Another interesting use of the CG, is to compare it with
user's conceptual understanding of the task, so that
we can find out whether the meaning of the complex icon
is consistent with user's conceptual understanding.
<!--. sp 2-->
<BR>
<BR>
<!--. NH -->
</P>
<H2>
5.
Implementation of the Visual Language Compiler
<!--. PP -->
</H2>
<P>
The SIL-ICON Compiler is an interactive system. The main function can
be summarized by the following procedure:
<!--. DS -->
<PRE>
procedure SIL-ICON_COMPILER()
begin
	initialize ID and OD by loading the files;
	repeat
	  display the current status;
	  prompt the user to select one of
	    the following functions:
		a. re-initialize ID or OD;
		b. interactively input/modify ID or OD;
		c. load an edited G;
		d. interactively input/modify G;
		e. invoke Iconic_Sentence_Parser;
		f. invoke Icon_Interpreter;
		g. invoke Generator;
		h. quit;
	until quit;
end SIL-ICON_COMPILER;
<!--. DE -->
</PRE>
<!--. PP -->
</P>
<P>
As an interactive system, the SIL-ICON Compiler provides a user oriented interface.
This feature is supported by function
<!--. B a-->
<B>a</B>
through
<!--. B d.-->
<B>d.</B>
These functions allows the user to interactively modify G, ID and OD.
The Iconic Sentence Parser and the Icon Interpreter also allow some user interaction.
<!--. PP -->
</P>
<P>
The Iconic Sentence Parser allows the user to interactively
create an iconic sentence by combining predefined icons.
The iconic sentence is then parsed.  After semantic interpretation, a natural language
description of its meaning is generated.
<!--. PP -->
</P>
<P>
The Icon Interpreter is the heart of SIL-ICON Compiler.
It also generates icons according to ID and OD, but the Icon Interpreter generates icons under the control of the formal icon grammar G.
<!--. PP -->
</P>
<P>
The syntax for the visual language is specified by G.
The working environment of the SIL-ICON Compiler includes G, ID and OD. The iconic sentence s entered by user will be
parsed according to G, and then the resultant complex icon structure will be given in the
form of CG. 
<!--. PP -->
</P>
<P>
The Icon Interpreter is described by the following procedure:
<!--. DS -->
<PRE>
	
Icon_Interpreter()
begin
     Parse an input iconic sentence using G;
     Invoke iconic operators in OD to evaluate the parsed
       iconic sentence and construct conceptual graph CG;
end Icon_Interpreter
<!--. DE -->
</PRE>
<p>
<!--. LL -->
<!--. PP -->
</P>
<P>
The evaluation of a parsed iconic sentence essentially
follows the recursive evaluation strategy described
as the EVAL procedure in Section 6.
<!--. PP -->
</P>
<P>
Finally, the Generator generates a realized icon-oriented system as its
output, according to the evaluation rules associated with the
icon rules, so that the realized icon-oriented system can
be reused by the user.
Therefore, the SIL-ICON Compiler serves the triple functions
of icon world navigation, icon interpretation, and icon-oriented
system generation.
<!--. PP -->
</P>
<P>
An example of the SIL-ICON compiler is given in Figure 1.11.
Figure 1.11(a) illustrates the screen layout for the iconic sentence
parser.  In the top row, various functions can be selected,
to draw an icon, copy an icon, parse the
iconic sentence, restore a previously saved icon,
move the icon, rotate the icon, perform
scale changes of icons, clear the screen, load icons from icon library,
enter text, and exit from parser.
In the bottom row, the predefined icons are displayed.  
<!--. PP -->
</P>
<center><img src="sk1fig/fig111a.gif" width=600></center>
<P>
Figure 1.11(b) illustrates the creation of an iconic sentence.  This
iconic sentence represents the line insertion operation.  The
iconic sentence is parsed, and the parser output is then displayed.
After semantic interpretation, the meaning of this iconic sentence
is also displayed.
<!--. PP -->
</P>
<center><img src="sk1fig/fig111b.gif" width=600></center>
<P>
Figures 11(c) and 11(d) are two other examples.
The iconic sentence in Figure 1.11(c) represents the
string replacement operation, and the iconic sentence
in Figure 1.11(d) represents the string deletion operation.
The parsed expression and the semantic interpreta
<!--. pn +5-->
tion are also shown.
<!--. PP -->
</P>
<center><img src="sk1fig/fig111c.gif" width=600></center>
<center><img src="sk1fig/fig111d.gif" width=600></center>
<P>
In Figure 1.12(a), the user enters the SIL-ICON compiler and
selects the &quot;load_g&quot; function to load the icon grammar G.
The user then selects the &quot;gen&quot; function to invoke the
icon system generator.  The icon system generator requires
a library file (&quot;Editor.c&quot;) so that it can create the
customized user interface program (&quot;IconSys.c&quot;).  This source
code is compiled, and then the user can execute
the user interface (&quot;IconSys&quot;).
<!--. PP -->
</P>
<center><img src="sk1fig/fig112a.gif" width=600></center>
<P>
In Figure 1.12(b), the screen layout of the customized
user interface (a simple screen editor) is shown.  The user
can select the &quot;insert&quot; menu function, and
Figure 1.12(c) shows the screen layout of the
functions available under the &quot;insert&quot; menu.
The user can select the &quot;Insert_line&quot;
function to enter text.
<p>
<center><img src="sk1fig/fig112b.gif" width=600></center>
<center><img src="sk1fig/fig112c.gif" width=600></center>
In Figure 1.12(d), the user selects the &quot;Insert_string&quot;
function to insert string.
<!--. PP As another example, a visual query interafce is illustrated-->
</P>
<center><img src="sk1fig/fig112d.gif" width=600></center>
<P>
in Figure 1.13.  The visual query shown is identical to the first
iconic sentence shown in Figure 1.2.
<!--. PP -->
</P>
<P>
The first version of the SIL-ICON compiler, SIL.V1, runs on the VAX780 computer and can only
generate text-oriented user interface.  The second version, SIL.V2,
runs on the SUN workstation and utilizes the graphics
package SUNCORE and SUNVIEW to generate icon-oriented user
interface. Both versions are written in the C programming language.
A third version, SIL.V3, incorporating more efficient
parser and interpreter, is currently under development
at the Visual Computer Laboratory of University of Pittsburgh.
<!--. bp -->
<HR>
l
<!--. sp 25-->
<BR>
<BR>
<!--. ce -->
<center><img src="sk1fig/fig113.gif" width=600></center>
<center>Figure 1.13  Visual query interface.</center>
<!--. sp 25-->
<BR>
<BR>
<!--. ce -->
<!--. SH -->
</P>
<H2>
<!--. NH -->
</H2>
<H2>
6.
Discussion
<!--. LP -->
</H2>
<P>
     Formal icon specification and the icon algebra form the basis of a design methodology
for visual languages and icon-oriented systems.
The formal icon specification handles the static aspect of an iconic system.
The icon algebra handles the dynamic aspect of an iconic system.
The iconic indexing technique, together with the concept of icon similarity,
allow the indexing and comparison of generalized icons.
<p>
     With a powerful icon algebra, we can write programs using
these very-high-level operators, to perform visual programming, image processing,
image database design, document editing, robotic manipulation, VLSI design, etc.
<p>
     In application to document editing, the icon (Xm,Xi) represents documents.  In (Xm,Xi), Xm is document structure and
meaning, and Xi is external document presentation.
A generic operator DOCUMENT(op, X, Y) then defines how documents can be
combined and its semantic effects.
The dematerialization operator DMA(Xi) gives the 
<!--. ul -->
<i>
symbolic reference
</i>
to document Xi.
In document editing, the indexing operator can be
used to reduce generalized icons &quot;with histories&quot; into some
canonical form.  In this way, each user may be dealing with
a specialized document (including its history of changes),
but a common canonical copy can be kept for public reference.
<p>
     In application to robotic manipulation, the icon (Xm,Xi) may represent a robotic arm.
In (Xm,Xi), Xm denotes the virtual arm, and Xi denotes the
physical arm.  Therefore, a generic robotic operator ROBOT(op, X) can
be defined, to manipulate the logical arm Xm and the physical arm Xi.
In general, any agent can be thought of as an icon (Xm,Xi),
with Xm representing the abstract model, and Xi the physical realization.
<p>
     We can apply iconic system to VLSI design, where a VLSI icon represents
a (design-specification, physical-layout) combination.  In other words,
in (Xm,Xi), Xm is VLSI design specification,
and Xi is physical layout.
We can have a generic iconic operator
VLSI(op, X, Y) = (VLSIm(op, Xm,Ym), VLSIi(op, Xi,Yi)), where VLSIi(op, Xi,Yi) specifies
how the two layouts are combined, and VLSIm(op, Xm,Ym) specifies how
the two design specifications are merged.
<p>
     The concept of generalized icons and icon algebra also provides
a unified framework for the theory of pattern recognition.
Conceptually, we can compare statistical pattern recognition,
syntactical pattern recognition, and clustering analysis as follows:
<p>
     In statistical pattern recognition, we are given an image ({},pj) and
we want to classify the image into class ci, and obtain ({ci},pj).
The transformation is:
<p>
     ENH( ({},pj) ) = ({ci},pj)
<p>
where ENH is an enhancement iconic operator.
<p>
     In syntactical pattern recognition, we are given an image ({},pj)
and we want to construct a formal iconic system G, whose head icon is xo.
The transformation is:
<p>
     SYN( ({},pj) ) = xo
<p>
where SYN is a synthesizing process to construct an iconic system G.
<p>
     In clustering analysis, we are given images {p1,...,pn}, and
we want to cluster them into classes {c1,...,cm}.
The transformation is:
<p>
<pre>
     CLU( ({c1},e),...,({cm},e),({},p1),...,({},pn) )
     = { ({ci},pj): 1=&lt;i=&lt;m, 1=&lt;j=&lt;n }
</pre>
<p>
     As described above, the theory of icons is applicable to the design of
icon-oriented user interfaces.  A visual language compiler can
be constructed, accepting the formal iconic system, the icon
operators, and definition of basic icons as input.  It can
then parse an iconic sentence to determine its syntactic structure
and semantic meaning.  
A realized icon-oriented system can be generated by the visual language compiler,
if the initial design is found to be satisfactory.
<p>
     The theory of icons, or the theory of dual representations of objects and
its semantics, therefore can be seen to be a unified
methodology for visual language design as well as icon-oriented system design.
<!--. bp -->
<HR>
<!--. KS -->
<BR>
<!--. B -->
<B>
APPENDIX 1: THE HEIDELBERG ICON SET
<!--. sp -->
<BR>
<BR>
<!--. nf -->
<BR>
APPENDIX 1.1: ELEMENTARY ICONS (ID)
<BR>
<!--. R -->
</B>
<!--. sp -->
<BR>
<BR>
<!--. nf -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.line-->
<img src=sk2fig/basic.line.gif><br>
<br>
LINE, rectangle,&quot;a line&quot;, OBJECT,,
<BR>
[OBJECT = LINE].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. nf -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.mline-->
<img src=sk2fig/basic.mline.gif><br>
<br>
MARKED_LINE, d_rectangle,&quot;a focused line&quot;, OBJECT,,
<BR>
[OBJECT = LINE = MARKED-LINE].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.char-->
<img src=sk2fig/basic.char.gif><br>
<!--. nf -->
<BR>
CHARACTER, square,&quot;a character&quot;, OBJECT,,
<BR>
[OBJECT = CHARACTER].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.mchar-->
<img src=sk2fig/basic.mchar.gif><br>
<!--. nf -->
<BR>
MARKED_CHARACTER, d_square,&quot;a focused character&quot;, OBJECT,,
<BR>
[OBJECT = CHARACTER = MARKED-CHARACTER].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.exregion-->
<img src=sk2fig/basic.exregion.gif><br>
<!--. nf -->
<BR>
EXCHANGE, diagonal,&quot;object defined place for object exchange&quot;, PLACE,,
<BR>
[PLACE = EXCHANGE_REGION] -&gt; (ON-REGION.[OBJECT:*x]) -&gt; [OBJECT:*y].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.arrows-->
<img src=sk2fig/basic.arrows.gif><br>
<!--. nf -->
<BR>
ARROW, d_arrow; u_arrow; r_arrow,&quot;location of new objects&quot;, EVENT,,
<BR>
[EVENT = INSERTION] -- (THEME) -&gt; [OBJECT]
<BR>
                       (event.GO) -&gt; [PATH = P.1] -&gt; (path.TO) -&gt; [PLACE].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.arrow.boxed-->
<img src=sk2fig/basic.arrow.boxed.gif><br>
<!--. nf -->
<BR>
BOX_ARROW, b_arrow,&quot;movement of objects&quot;, EVENT,,
<BR>
[EVENT = MOVEMENT] -- (THEME) -&gt; [OBJECT]
<BR>
                      (event.GO) -&gt; [PATH = P.3] -&gt; (path.FROM) -&gt; [PLACE]
<BR>
                                              (path.TO) -&gt; [PLACE].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/basic.cross-->
<img src=sk2fig/basic.cross.gif><br>
<!--. nf -->
<BR>
CROSS, cross,&quot;deletion of objects&quot;, EVENT,,
<BR>
[EVENT = DELETION] -- (THEME) -&gt; [OBJECT]
<BR>
                      (event.GO) -&gt; [PATH = P.2] -&gt; (path.TO) -&gt; [NON-EX].
<BR>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. nf -->
<BR>
<!--. sp -->
<BR>
<BR>
GAP, gap,&quot;place between two objects&quot;, PLACE,,
<BR>
[PLACE = BETWEEN] -&gt; (place.BEFORE) -&gt; [OBJECT].
<BR>
<p>
<p>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. sp -->
<BR>
<BR>
<!--. KS -->
<BR>
<!--. B -->
<B>
APPENDIX 1.2: INTERMEDIARY ICONS
<br>
<BR>
<!--. R -->
</B>
<!--. PS < icon/icon.sys.picfig/inter.onrow-->
<img src=sk2fig/inter.onrow.gif><br>
<!--. nf -->
<BR>
ON_ROW, fpp(LINE) ^ fpp(GAP) ^ fpp(MARKED_LINE),&quot;place for a line&quot;, PLACE,
<BR>
[PLACE = ROW] -&gt; (ON-ROW.[OBJECT = LINE]) -&gt; [OBJECT = TEXT];
<BR>
PLACE,,
<BR>
[PLACE = ROW] -&gt; (BEFORE) -&gt; [OBJECT = LINE].
<BR>
--------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/inter.onpoint-->
<img src=sk2fig/inter.onpoint.gif>
<br>
<!--. nf -->
<BR>
ON_POINT, fpp(CHARACTER) + fpp(GAP) + fpp(MARKED_CHARACTER),
<BR>
&quot;place for a character&quot;, PLACE,
<BR>
[PLACE = POINT] -&gt; (ON-POINT.[OBJECT = CHARACTER]) -&gt; [OBJECT = TEXT];
<BR>
PLACE,,
<BR>
[PLACE = POINT] -&gt; (BEFORE) -&gt; [OBJECT = CHARACTER].
<BR>
-------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/inter.mstring-->
<img src=sk2fig/inter.mstring.gif>
<br>
<br>
<!--. PS < icon/icon.sys.picfig/inter.mstring1-->
<img src=sk2fig/inter.mstring1.gif>
<br>
<!--. nf -->
<BR>
MARKED_STRING, fpp(MARKED_CHARACTER) + fpp(CHARACTER) + fpp(MARKED_CHARACTER);
<BR>
fpp(MARKED_CHARACTER) + fpp(CHARACTER) + fpp(CHARACTER) + fpp(MARKED_CHARACTER),
<BR>
&quot;focused string&quot;, OBJECT,,
<BR>
[OBJECT = STRING].
<BR>
-------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/inter.mregion-->
<img src=sk2fig/inter.mregion.gif>
<!--. nf -->
<BR>
EXCHANGE_REGION,fpp(EXCHANGE) &amp; fpp(MARKED_STRING), &quot;string defining an exchange place&quot;, 
<BR>
PLACE,, [PLACE = REGION] -&gt; (ON-REGION.[OBJECT = STRING]) -&gt; [OBJECT = TEXT]
<BR>
-------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/inter.cstring-->
<img src=sk2fig/inter.cstring.gif>
<!--. nf -->
<BR>
CREATED_STRING, fpp(CHARACTER) + fpp(CHARACTER) + fpp(CHARACTER),
<BR>
&quot;string to be created&quot;, OBJECT,,
<BR>
[OBJECT = STRING].
<BR>
--------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. sp -->
<BR>
<BR>
<!--. KS -->
<BR>
<!--. B -->
<B>
APPENDIX 1.3: THE FIVE EDITING ICONS
<BR>
<BR>
<!--. R -->
</B>
<!--. PS < icon/icon.sys.picfig/icon.insert-->
<img src=sk2fig/icon.insert.gif>
<BR>
<!--. nf -->
<BR>
INSERT_LINE, r_arrow + fpp(ON_ROW),&quot;insert a line&quot;, EVENT,,
<BR>
<pre>
[EVENT = INSERT_LINE] -- (THEME) -&gt; [OBJECT = LINE]
<BR>
                        (event.GO) -&gt; [PATH = P.1.1] -&gt; (path.TO) -&gt; [PLACE = ROW].
<BR>
</pre>
--------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/icon.instring-->
<img src=sk2fig/icon.instring.gif>
<!--. nf -->
<BR>
<BR>
INSERT_STRING, d_arrow ^ fpp(ON_POINT),&quot;insert a string&quot;, EVENT,,
<BR>
<pre>
[EVENT = INSERT_STRING] -- (THEME) -&gt; [OBJECT = STRING]
<BR>
                          (event.GO) -&gt; [PATH = P.1.2] -&gt; (place.TO) -&gt; [PLACE = POINT].
<BR>
</pre>
--------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/icon.delete-->
<img src=sk2fig/icon.delete.gif>
<!--. nf -->
<BR>
DELETE_STRING, fpp(CROSS) &amp; fpp(MARKED_STRING),&quot;delete a string&quot;, EVENT,,
<BR>
<pre>
[EVENT = DELETE_STRING] -- (THEME) -&gt; [OBJECT = STRING]
<BR>
                          (event.GO) -&gt; [PATH = P.2] -&gt; (path.TO) -&gt; [NON-EX].
</pre>
<BR>
--------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/icon.replace-->
<img src=sk2fig/icon.replace.gif>
<!--. nf -->
<BR>
REPLACE_STRING, ((fpp(EXCHANGE) &amp; fpp(MARKED_REGION)) ^ u_arrow) ^ 
<BR>
fpp(CREATED_STRING),&quot;replace a string&quot;, EVENT,,
<BR>
<pre>
[EVENT = REPLACE_STRING] -- (THEME) -&gt; [OBJECT = STRING]
<BR>
                           (event.GO) -&gt; [PATH = P.1.3] -&gt; (path.TO) -&gt; [PLACE = REGION].
<BR>
</pre>
--------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. KS -->
<BR>
<!--. PS < icon/icon.sys.picfig/icon.move-->
<img src=sk2fig/icon.move.gif>
<!--. nf -->
<BR>
MOVE_STRING, (fpp(MARKED_STRING) &amp; fpp(BOXED_ARROW)) ^ 
<BR>
fpp(ON_POINT),&quot;move a string to a new place&quot;, EVENT,,
<BR>
<pre>
[EVENT = MOVE_STRING] -- (THEME) -&gt; [OBJECT = STRING]
<BR>
                         (event.GO) -&gt; [PATH = P.3.1] -- (path.FROM) -&gt; [PLACE =  REGION]
<BR>
                                                 (path.TO) -&gt; [PLACE = POINT].
<BR>
</pre>
---------------------------------------------------------------------------
<BR>
<!--. KE -->
<BR>
<!--. sp 5-->
<BR>
<BR>
<!--. SH -->
</P>
<b>
APPENDIX 2: FORMAL ICON GRAMMAR G FOR THE HEIDELBERG ICON SET
</b>
<BR>
<!--. EQ -->
<!--
<PRE>
delim $$
<BR>
define Cm '<B>COM sub m</B><I>'
<BR>
define Ci '</I><B>COM sub i</B><I>'
<BR>
define Hm '</I><B>HOR sub m</B><I>'
<BR>
define Hi '</I><B>HOR sub i</B><I>'
<BR>
define Vm '</I><B>VER sub m</B><I>'
<BR>
define Vi '</I><B>VER sub i</B><I>'
<BR>
-->
<!--. EN -->
</PRE>
<!--. PP -->
<P>
In the grammar rule for the Heidelberg Icon Set, each right-hand side consists of three components,
specifying
the logical part, the physical part and the evaluation part.
The evaluation part is represented as a string which can be mapped to
an implementation dependent object related to the evaluation as discussed
in Section 3.
The
<!--. I nil-->
<I>nil</I>
evaluation part means inheritance.  Of course, the elementary icon with nil evaluation
part simply means no operation.
<!--. SH -->
</P>
<b>
APPENDIX 2.1:  ELEMENTARY ICON SET
<BR>
<!--. PP -->
</b>
<P>
The elementary icon set in ID is predefined by the system manager.
<BR>
<!--. DS -->
<PRE>
	E1.	Line ::= ( LINE, rectangle, nil );
<BR>
	E2.	Marked_line ::= ( MARKED_LINE, d_rectangle, &quot;Line_Pointer&quot; );
<BR>
	E3.	Character ::= ( CHARACTER, square, nil );
<BR>
	E4.	Marked_char ::= ( MARKED_CHARACTER, d_square, &quot;Char_Pointer&quot; );
<BR>
	E5.	Exchange ::= ( EXCHANGE, diagonal, &quot;Generic_Exchange&quot; );
<BR>
	E6.	Up_arrow ::= ( ARROW, u_arrow, &quot;Generic_Arrow&quot; );
<BR>
	E7.	Down_arrow ::= ( ARROW, d_arrow, &quot;Generic_Arrow&quot;  );
<BR>
	E8.	Right_arrow ::= ( ARROW, r_arrow, &quot;Generic_Arrow&quot; );
<BR>
	E9.	Box_arrow ::= ( BOX_ARROW, b_arrow, &quot;Boxed_Arrow&quot; );
<BR>
	E10.	Cross ::= ( CROSS, cross, &quot;Generic_Kill&quot; );
<BR>
	E11.	Gap ::= (  GAP, gap, nil).
<BR>
<!--. DE -->
</PRE>
<!--. SH -->
</P>
<b>
APPENDIX 2.2:  INTERMEDIARY ICONS
<BR>
<!--. PP -->
</b>
<P>
The intermediary icons are complex icons produced from the elementary icons,
but are used only for the definition of more complex icons.
Most intermediary icons are predefined by the system manager.
They can also be defined or redefined by the end user.
<!--. DS -->
<PRE>
	I1.	On_row ::= (	{<b>VER<sub>m</sub></b>, Line, Gap, Marked_line},
<BR>
				{<b>VER<sub>i</sub></b>, Line, Gap, Marked_line},
<BR>
				nil );
<BR>
	I2.	On_point ::= (	{<b>HOR<sub>m</sub></b>, Character, Marked_char},
<BR>
				{<b>HOR<sub>i</sub></b>, Character, Marked_char},
<BR>
				nil );
<BR>
	I3.	Marked_string ::= ({<b>HOR<sub>m</sub></b>, Marked_char, Character, Marked_char},
<BR>
				{<b>HOR<sub>i</sub></b>, Marked_char, Character, Marked_char},
<BR>
				nil );
<BR>
	I4.	Marked_region ::= ({<b>HOR<sub>m</sub></b>, Marked_char, Character, Character, Marked_char},
<BR>
				{<b>HOR<sub>i</sub></b>, Marked_char, Character, Character, Marked_char},
<BR>
				nil );
<BR>
	I5.	Created_string ::= ({<b>HOR<sub>m</sub></b>, Character, Character, Character},
<BR>
				{<b>HOR<sub>i</sub></b>, Character, Character, Character},
<BR>
				&quot;Create_String&quot; );
<BR>
	I6.	Exchange_region ::= ({<b>COM<sub>m</sub></b>, Exchange, Marked_region},
<BR>
				{<b>COM<sub>i</sub></b>, Exchange, Marked_region},
<BR>
				nil );
<BR>
	I7.	Boxed_string ::= ({<b>COM<sub>m</sub></b>, Box_arrow, Marked_string},
<BR>
				{<b>COM<sub>i</sub></b>, Box_arrow, Marked_string},
<BR>
				nil );
<BR>
<!--. DE -->
</PRE>
<!--. SH -->
</P>
<b>
APPENDIX 2.3:  TOP-LEVEL COMPLEX ICONS FOR THE HEIDELBERG EDITOR
<BR>
<!--. PP -->
</b>
<P>
The last five rules define the Heidelberg Icon Set.
<BR>
<!--. DS -->
<PRE>
	C1.	Insert_line ::= (	{<b>HOR<sub>m</sub></b>, Right_arrow, On_row},
<BR>
					{<b>HOR<sub>i</sub></b>, Right_arrow, On_row},
<BR>
					&quot;Insert_line&quot; );
<BR>
	C2.	Insert_string ::= ({<b>HOR<sub>m</sub></b>, Down_arrow, On_Point},
<BR>
					{<b>HOR<sub>i</sub></b>, Down_arrow, On_Point},
<BR>
					&quot;Insert_string&quot; );
<BR>
	C3.	Delete_string ::= ({<b>COM<sub>m</sub></b>, Cross, Marked_string},
<BR>
					{<b>COM<sub>i</sub></b>, Cross, Marked_string},
<BR>
					&quot;Delete_string&quot; );
<BR>
	C4.	Replace_string ::= ({<b>VER<sub>m</sub></b>, Up_arrow, Created_string, Exchange_region},
<BR>
					{<b>VER<sub>i</sub></b>, Up_arrow, Created_string, Exchange_region},
<BR>
					&quot;Replace_string&quot; );
<BR>
	C5.	Move_string ::= ({<b>VER<sub>m</sub></b>, Boxed_string, On_point},
<BR>
					{<b>VER<sub>i</sub></b>, Boxed_string, On_point},
<BR>
					&quot;Move_string&quot; );
<BR>
<!--. DE -->
</PRE>
<!--. PP -->
</P>
<P>
In the above rules, if we define explicitly the evaluation procedure for each complex icon,
<BR>
such definition will override the evaluation procedure produced from ID and OD.
<BR>
If the ID and OD are well defined, and the meaning of complex icons are derivable from ID using operators in OD, then the user can use a
<BR>
<!--. I nil-->
<I>nil</I>
evaluation part to obtain the icon interpretation produced by SIL-ICON Compiler.
<BR>
<!--. sp 2-->
<BR>
<BR>
<!--. B -->
</I><B>
APPENDIX 3: THE FORMAL GRAMMAR IG OF ICON DICTIONARY ENTRIES
<BR>
<p>
<!--. R -->
</B>
<!--. nf -->
<BR>
    ENTRY--&gt;NAME,SKETCH{;SKETCH},DESC,TYPE,EVAL,CG{;TYPE,EVAL,CG},ATTRIBUTE.
<BR>
    NAME--&gt;STRING
<BR>
    DESC--&gt;[STRING { BLANK STRING} ]
<BR>
    TYPE--&gt;STRING
<BR>
    EVAL--&gt;[STRING]
<BR>
    CG--&gt;CONCEPT [RLINK] | RELATION CONLINK
<BR>
    ATTRIBUTE--&gt;[STRING{;STRING}]
<BR>
    STRING--&gt;LETTER STRING | LETTER
<BR>
    LETTER--&gt;A | B | ... | Z | _ | a | b | ... | z
<BR>
    BLANK--&gt; ' '
<BR>
<!--. B -->
<!--. fi -->
<BR>
<!--. ad -->
<!--. LP -->
</P>
<P>
<!--. PP -->
</P>
<P>
In the above, the SKETCH is a pattern string described by the picture grammar PG.
<!--. bp -->
<HR>
<!--. ls 1-->
<!--. ul -->
<i>
<b>
References:
</b>
</i>
<p>
[CHANG70] S. K. Chang, &quot;A Method for the Structural Analysis of Two-Dimensional 
Mathematical Expressions&quot;, 
<!--. ul -->
<i>
Information Sciences, 
</i>
Vol. 2,
1970, 253-272.
<p>
[CHANG71] S. K. Chang, &quot;Picture Processing Grammar and its Applications&quot;, 
<!--. ul -->
<i>
Information Sciences, 
</i>
Vol. 3, 1971, 121-148.
<p>
<p>
[CHANG84] S. K. Chang and S. H. Liu, &quot;Picture indexing and Abstraction
Techniques for Pictorial Databases&quot;,
IEEE Transactions on Pattern Analysis and Machine Intelligence, July 1984,
475-484.
<p>
[CHANG85] S. K. Chang, E. Jungert, S. Levialdi, G. Tortora, and T. Ichikawa,
&quot;An Image Processing Language with Icon-Assisted Navigation&quot;, IEEE Transactions on Software Engineering, August 1985, 811-819.
<p>
[CHANG86] S. K. Chang et. al., &quot;Iconic Indexing by 2D Strings&quot;, Proceedings of IEEE Workshop on Visual Languages, Dallas, Texas, June 25-27, 1986.
<p>
[CHANG87] S. K. Chang, G. Tortora and B. Yu, &quot;Icon Purity - Toward a Formal Theory of Icons&quot;, Proceedings of IEEE Workshop on Visual Languages, Linkoping, Sweden, August 1987.
<p>
[CHI85] Chi, U.L. &quot;Formal Specification of User Interfaces: A 
Comparison and Evaluation of four Axiomatic Approaches&quot;, IEEE Transactions
on Softwareengineering, SE-11, 8. pp.671 - 685.
<p>
[CLARISSE85] O. Clarisse and S. K. Chang, &quot;An Icon Manager in Lisp&quot;, Proceedings of 1985 IEEE Workshop on Languages for Automation, Mallorca, Spain, June 28-29, 1985, 116-131. 
<p>
[EDMONDS82] Edmonds, E.A. &quot;T Man-Computer Interface - A Note on Concepts and
Design&quot;, Int.J.Man-Machine Studies, 16, pp 231 - 236.
<p>
[FILE83]  G. File, &quot;Interpretation and Reduction of Attribute Grammars&quot;,
Acta Informatica 19, 115-150, 1983.
<p>
[FU74] K. S. Fu,
&quot;Syntactic Methods in Pattern Recognition&quot;,
Academic Press, 1974.
<p>
[GREEN85] Green, M. &quot;Design Notations and User Interface Management Systems&quot;, in
Pfaff, G.E., User Interface Management Systems, Springer: Berlin -
Heidelberg - New York - Tokyo.
<p>
[GREEN87] T.R.G. Green, F. Schiele &amp; S.J. Payne, 
&quot;Formalizable Models of User Knowledge in
Human - Computer Interaction&quot;, to appear in: Green, Hoc et al. (Eds.),
Theory and Outcomes in Human-Computer Interaction, Academic Press,
London 1987.
<p>
[GUEST82] Guest, S.P. &quot;The Use of Software Tools for Dialogue Design',
Int.J.Man-Machine Studies, 16, pp 263 - 285.
<p>
[HOPPE86] H. U. Hoppe, M. Tauber, J. E. Ziegler, &quot;A Survey of Models and Formal Description Methods in Human-Computer Interface with Example Applications&quot;, ESPRIT Project 385 HUFIT, Report B.3.2a, June 1986.
<!--. sp -->
<BR>
<BR>
[JACKENDOFF83], R. Jackendoff, &quot;Semantics and Cognition&quot;, MIT Press,
Cambridge, Mass., 1983.
<p>
[JACOBS83] Jacobs, R.J.K. &quot;Using Formal Specifications in the Design of
a Human-Computer Interface&quot;, Comm.ACM, 26, 4, pp 259 - 264.
<p>
[KAMIMURA83] T. Kamimura, &quot;Tree Automata and Attribute Grammars&quot;,
Information and Control, 57, 1-20, 1983.
<p>
[KIERAS83] Kieras, D.E. &amp; Polson, P. &quot;A Generalized Network Representation
of Interactive Systems&quot;, Proc. CHI'83, Boston, December 1983.
<p>
[KIERAS85] Kieras, D.E. &amp; Polson, P. &quot;An Approach to the Formal Analysis
of User Complexity&quot;, Int.J.Man-Machine Studies, 22, pp 365 - 394.
<!--. sp -->
<BR>
<BR>
[KEPPEL&amp;ROHR84] E. Keppel &amp; G. Rohr, &quot;Prototyping - A Method to Explore Human
Factors Aspects in Application Software&quot;. In: H.W.Hendrik &amp; W.Brown (Eds.):
Human Factors in Organizational Design and Management. North Holland,
Amsterdam - New York.
<p>
[KORFHAGE86] R. R. Korfhage and M. A. Korfhage, &quot;Criteria for Iconic Languages&quot;, in Visual Languages, edited by S. K. Chang et. al., Plenum Pub. Co. 1986.
<p>
[LODDING82] K. N. Lodding, &quot;Iconics - A Visual Man-Machine Interface&quot;, Proceedings of National Computer Graphics Association Conference, Anaheim, California, 1982, Vol. 1, 221-233.
<p>
[MORAN81] Moran, T.P. &quot;The Command Language Grammar: A Representation for the
User Interface of Interactive Computer Systems&quot;, Int.J.Man-Machine Studies,
15, pp 3 - 50.
<p>
[NORMAN83] Norman, D. A. &quot;Some Observations in Mental Models&quot;, In: Gentner et al.
(eds.), Mental Models. Erlbaum: Hillsdale, N.J.
<p>
[OBER83] Oberquelle, H., Kupka, I. &amp; Maass, S. &quot;A View of Human-Machine
Communication and Co-operation&quot;, Int.J.Man-Machine Studies, 19, 4, pp 309 -
333.
<p>
[PAYNE84] Payne, S. J. &quot;Task Action Grammars&quot;, Proc. INTERACT, IFIP, London,
September 1984, pp 139 - 144.
<p>
[PFAFF85] Pfaff, G. E. &quot;User Interface Management Systems&quot;, Springer:
Berlin - Heidelberg - New York - Tokyo.
<p>
[REISNER84] Reisner, P. H. &quot;Formal Grammars as a Tool for Analyzing Ease of Use:
Some Fundamental Concepts&quot;, In: Thomas et al. (eds.), Human Factors
in Computer Systems. Ablex: Norwood.
<p>
[ROHR84] G. Rohr, &quot;Understanding Visual Symbols&quot;,
Proceedings of IEEE Workshop on Visual Languages,
Hiroshima, Japan, December 9-11, 1984.
<!--. sp -->
<BR>
<BR>
[ROHR&amp;KEPPEL84] G.Rohr &amp; E.Keppel, &quot;Iconic Interfaces: Where to Use and How to
Construct&quot;. In: Hendrick, H.W. &amp; Brown, O.jr. (Eds.). Human Factors in
Organizational Design and Management. North Holland, Amsterdam - New York, 
1984.
<!--. sp -->
<BR>
<BR>
[ROHR86] G. Rohr, &quot;Using Visual Concepts&quot;, in: Chang, Ichikawa &amp; Ligomenides
(Eds.), Visual Languages, Plenum Press, New York 1986.
<p>
[SHNEID86] Ben Shneiderman,
<!--. ul -->
<i>
Designing the User Interface,
</i>
Addison-Wesley 1986.
<!--. sp -->
<BR>
<BR>
[SOWA84] J. F. Sowa, &quot;Conceptual Structures&quot;, Addision-Wesley Publ., Reading,
Mass, 1984.
<p>
[TANIMOTO76] S. L. Tanimoto, &quot;An Iconic/Symbolic Data Structuring Scheme,&quot; 
Pattern Recognition and Artificial Intelligence,
Academic Press, 1976, 452-471. 
<p>
[TANIMOTO86] S. Tanimoto and Marcia S. Runyan, &quot;PLAY: An Iconic Programming System for Children&quot;, in Visual Languages, edited by S. K. Chang et. al., Plenum Pub. Co. 1986.
<!--. sp -->
<BR>
<BR>
[TAUBER86] M. J. Tauber, &quot;Top-Down Design of Human-Computer Interfaces&quot;, in:
Chang, Ichikawa &amp; Ligomenides (Eds.), Visual Languages,
Plenum Press, New York 1986.
<!--. sp -->
<BR>
<BR>
[TAUBER87] M.J. Tauber, &quot;On Mental Models and the User Interface&quot;,
to appear in: Green, Hoc, Murray &amp; Veer (Eds.):
Theory and Outcomes in Human - Computer
Interaction, Academic Press, London 1987.
<p>
[WASSER85] Wassermann, A.I. &quot;Extending State Transition Diagrams for the
Specification of Human-Computer Interaction', IEEE Trans.Software Eng.,
SE-11, pp 699 - 713.
<p>
[WEBSTER83] Webster's New Twentieth Century Dictionary, Unabridged, 1983.
<!--. bp -->
<HR>
<!--. SH -->
</P>
<H2>
<!--. ce -->
<center>Exercises</center>
<!--. sp -->
<BR>
<BR>
<!--. PP -->
</H2>
<P>
(1) Identify the pure icons, impure icons, image icons, label icons,
elementary icons and complex icons of the following iconic system:
<p>
<!--. nf -->
<BR>
<!--. na -->
x<sub>0</sub> ::= ({x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>},p<sub>0</sub>)
<BR>
x<sub>1</sub> ::= ({c<sub>1</sub>},p<sub>1</sub>)
<BR>
x<sub>2</sub> ::= ({c<sub>2</sub>},p<sub>1</sub>)
<BR>
x<sub>3</sub> ::= ({x<sub>4</sub>,x<sub>5</sub>},p<sub>2</sub>)
<BR>
x<sub>4</sub> ::= ({},p<sub>3</sub>)
<BR>
x<sub>5</sub> ::= ({c<sub>3</sub>},e)
<BR>
<!--. fi -->
<BR>
<!--. ad -->
<p>
<!--. PP -->
</P>
<P>
(2) Describe how the iconic operators operate on the icons of the formal iconic system G2, illustrated by Figure 1.7 in Section 7, to realize a menu-driven user interface.
<p>
<!--. PP -->
</P>
<P>
(3) Describe the tree menu system of Figure 1.14 as a formal iconic system G3.
<!--. GS -->
<p>
<!-- <img src=sk2fig/f11.gif> -->
</p>
<!--. GE -->
<!--. sp -->
<BR>
<BR>
<!--. ce -->
<center><img src="sk1fig/fig115.gif" width=600></center>
<center>Figure 1.14.    A tree menu system.</center>
<!--. sp -->
<BR>
<BR>
<!--. PP -->
</P>
<P>
(4) Perform the syntactic analysis of the complex icon,
<!--. ul -->
<i>
delete string,
</i>
in the Heidelberg Icon Set (see Figure 1.10), and describe 
how the parsing tree is obtained.
<p>
<!--. PP -->
</P>
<P>
(5) Perform the semantic analysis of the parsed iconic sentence,
<!--. ul -->
<i>
delete string,
</i>
and describe step by step
the synthesis of the conceptual graph interpretation.
<!--. sp -->
<BR>
<BR>
<!--. pp -->
(6) A teleshopping system utilizes home TV monitor to display
merchadise, and the shopper can point to the merchandise if further
information is needed, or similar types of goods are to be
displayed, or shop locations carrying such itmes are desired.
(a) Use your imagination to design a set of icons, including
elementary icons, operator icons, composite icons, process
icons, etc., for this teleshopping system.  
You should have at least one icon for each type mentioned above.
(b) Give a formal description of the above iconic system, using
the formal grammar approach.
(c) Describe
typical iconic sentences in this visual language, and how
they are interpreted.
<p>
</P>
<HR>
</BODY>
</HTML>

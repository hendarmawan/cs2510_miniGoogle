<HTML>

<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="GENERATOR" CONTENT="Notepad/Robert Hofmann">
<BASE TARGET="1502main">
<TITLE>Unit 1e : Creating the Comparison Sub-Block</TITLE>
</HEAD>

<BODY BACKGROUND="../Unitbkg.jpg">
<H2><CENTER>Unit 1e</CENTER></H2>
<H2><CENTER>Creating the Comparison Sub-Block</CENTER></H2>

<H3><CENTER>Efficient Comparison in the MIPS ALU</CENTER></H3>

<P>
  For the comparison operations,  Set on Less Than (SLT) and 
  Set on Less Than Unsigned (SLTU), we wish to determine whether
  the input <I>A</I> is less than the input <I>B</I>.  If it is,
  we wish to set the result to <B>X"0000000000000001"</B>.  If it is not,
  we wish to set the result to <B>X"0000000000000000"</B>.
</P>
<P>
  Let's start by looking at the calculation we wish to perform:
  <I>A < B</I>.  Using a little simple algebra, this expression
  can be rewritten as <I>A - B < 0</I>.  If we were to subtract
  <I>B</I> from <I>A</I>, then all that would remain is the
  relatively trivial matter of determining whether the result
  is less than zero.  Instead of a large comparator which will 
  consume a number of gates, we can once again reuse our single
  adder with a minimal amount of logic looking at the output.
</P>
<P>
  First, we must make sure that our existing <I>Arithmetic</I>
  sub-block is performing a subtraction operation.  This will
  occur when <I>ALUOp(1 DOWNTO 0)</I> is either "10" or "11".
  fortunately, we only have two comparison operations to perform.
  <I>SLT</I> will require a signed subtraction, thus it will
  be encoded as <I>ALUOp(1 DOWNTO 0) = "10"</I>.  <I>SLTU</I>
  will require an unsigned subtraction, thus it will be 
  encoded as <I>ALUOp(1 DOWNTO 0) = "11"</I>.  The remaining
  two encodings for this sub-block will be undefined.
</P>
<P>
  Now, the question is how do we determine if the result is 
  less than zero based on the four inputs which we have
  defined to the <I>Comparison</I> sub-block: CarryOut from the
  subtractor, Bit 63 of the subtractor result (RSign), Bit 63
  of the input <I>A</I> (ASign), and Bit 63 of the input <I>B</I>
  (BSign). 
</P>
<P>
  Lets start with the Signed version.  There are four possible 
  combinations of the signs of the inputs: both are positive;
  both are negative; <I>A</I> is positive and <I>B</I> is negative; 
  <I>A</I> is negative and <I>B</I> is positive.  When the signs
  of the inputs are different, our problem is trivial.  If <I>A</I>
  is negative and <I>B</I> positive, then A <B>MUST</B> be less than
  <I>B</I>.  Conversely, if <I>A</I> is positive and <I>B</I> is 
  negative then <I>A</I> <B>CAN NEVER</B> be less than <I>B</I>.
  When the inputs have the same sign we need to look at the result
  of the signed subtraction.  Two inputs with the same sign can
  never cause an overflow in subtraction, so we do not have to
  concern ourselves with an incorrect answer due to that.  If the
  inputs are of the same sign, then whenever <I>A</I> is smaller
  than <I>B</I> the result of subtracting <I>A - B</I> <B>MUST</B>
  be a negative number.  So, if the sign of the result, <I>SignR</I>,
  is negative we have <I>A < B</I> and if it is positive then 
  we have <I>A > B</I>.
</P>
<P>
  For the Unsigned version of the comparison we have a simple test.
  In unsigned representation, <I>A</I> and <I>B</I> are both
  positive numbers.  Subtracting two positive numbers will result
  in a positive number if <I>A > B</I> or a negative number if
  <I>A < B</I>.  However, we cannot represent a negative number
  with an Unsigned integer: if we try we will have an overflow 
  condition.  Overflow for unsigned subtraction means that
  the result is a negative number (it is impossible to subtract
  two unsigned numbers and get a result too large to represent).
  We can test for the occurence of overflow in unsigned subtraction
  by looking at the Carry Out of the most significant bit.  In unsigned
  addition, the existence of a Carry Out indicates overflow.  In 
  unsigned subtraction, however, the situation is reversed: Carry Out
  high is the normal state and Carry Out low indicates overflow.
  Thus, since we are performing unsigned subtraction in our SLTU, 
  if there is no Carry Out, then we had an overflow and <I>A - B</I>
  is less than zero and <I>A < B</I> is true.  If there is a
  Carry Out, then <I>A - B</I> is greater than zero and <I>A < B</I>
  is false.
</P>
<P>
  Since we are only concerned with four input bits to determine our
  output, we will be implementing the <I>Comparison</I> sub-block 
  by creating a <I>Truth Table</I> view.
</P>

<H3><CENTER>Creating a Truth Table View for the Comparison Sub-Block</CENTER></H3>

<UL>
<LI>
  <P>
    First, you need to open a new <I>Truth Table</I> view for the
    <I>Comparison</I> sub-block.  Do this by opening the <I>ALU</I>
    block diagram, right-clicking over the <I>Comparison</I>
    sub-block, and selecting <I>Open/New View</I> from the pop-up
    menu.  In the <I>Create New View</I> window which appears,
    select <I>Truth Table</I> from the list box and accept the default
    name of <I>table.tt</I>.
  </P>
  <P>
    The <I>Truth Table</I> view window will appear similar to 
    Figure 1.
  </P>

  <CENTER>
  <P>
    <IMG SRC="./Comp1.jpg">
    <H4>Figure 1</H4>
  </P>
  </CENTER>
</LI>

<LI>   
  <P>
    <b>First, relabel the columns in the following order: ALUOp (1 downto 0), Asign, Bsign, Rsign, CarryOut, ComparisonR.</b>
    You may resize the rows and columns of the <I>Truth Table</I>
    by moving the pointer over the lines separating the row and
    column headers (which are in gray), left-clicking, and dragging
    to the desired height or width just like in a spreadsheet program.
    Resize the <I>ASign</I>, <I>BSign</I>, <I>RSign</I>, and <I>CarryOut</I>
    columns so that the signal names just fit.  Now make the <I>ComparisonR</I>
    column much larger because it will be holding a 64-bit wide vector.
    Your view should look something like Figure 2.
  </P>
  <CENTER>
  <P>
    <IMG SRC="./Comp2.jpg">
    <H4>Figure 2</H4>
  </P>
  </CENTER>
</LI>

<LI>
  <P>
    We will need more than four rows in this <I>Truth Table</I>.  A row can be
    added, by right-clicking anywhere over the table and selecting <I>Add Row</I>
    from the pop-up menu.  Add six more rows so that your table looks like 
    Figure 3.
  </P>
  <CENTER>
  <P>
    <IMG SRC="./Comp3.jpg">
    <H4>Figure 3</H4>
  </P>
  </CENTER>
</LI>

<LI>
  <P>
    Now we will start to add information to the table.  Values are entered
    by left-clicking on the appropriate cell and typing in the data. 
    <I>Don't Care</I> values are specified by leaving a cell empty.  Don't
    care's are useful to shorten the length of the table when a particular
    entry does not depend on the state of one or more of the inputs.
    For example, to completely specify the truth table for our design with
    six bits of input we would need 64 rows but by using don't cares we
    can reduce that to 10.
  </P>
  <P>
    The first thing to look at is the fact that we don't have a defined
    operation for ALUOp = "00" or ALUOp = "01".  These operations should
    never actually be issued for the <I>Comparison</I> unit, but as
    a default, we will output the value X"0000000000000000".  So, in the
    <I>ALUOp</I> cell of the first row, enter the value <I>00</I> and
    in the corresponding <I>ComparisonR</I> cell enter
    <I>"0000000000000000000000000000000000000000000000000000000000000000"</I> (Using Hex notation here will
    not work with std_logic_vectors, the design will generate, but there will
    be errors when you attemp to compile).  In the same manner, enter 
    row two with <I>ALUOp</I> as <I>01</I> and <I>ComparisonR</I> as
    <I>"0000000000000000000000000000000000000000000000000000000000000000"</I>.  Your table should now
    look like Figure 4.  We have now specified 32 rows of data in 
    2 rows because of the use of don't care values for the bits <I>ASign</I>,
    <I>BSign</I>, <I>RSign</I>, and <I>CarryOut</I>.
  </P>
  <CENTER>
  <P>
    <IMG SRC="./Comp4.jpg">
    <H4>Figure 4</H4>
  </P>
  </CENTER>
</LI>

<LI>
  <P>
    Now we will look at the signed comparison operation, <I>SLT</I>,
    which is performed when <I>ALUOp</I> is equal to "10".  Remember 
    from above that there were three possible situations: <I>A</I> and
    <I>B</I> have the same sign, <I>A</I> is positive and <I>B</I> is
    negative, or <I>A</I> is negative and <I>B</I> is positive.
  </P>
  <P>
    Let's start with the case of both inputs having the same sign.  This
    occurs when <I>ASign = '0'</I> and <I>BSign = '0'</I> or <I>ASign = '1'</I> 
    and <I>BSign = '1'</I>.  In each case all we need to do is look at the 
    sign of the result, <I>RSign</I>.  If <I>RSign = '0'</I> then the result
    is positive and we want to output FALSE, or "0000000000000000000000000000000000000000000000000000000000000000".
    If <I>RSign = '1'</I> then the result is negative and the output is TRUE, 
    or "0000000000000000000000000000000000000000000000000000000000000001".  We can do this by entering four lines 
    on the table as seen in Figure 5.
  </P>
  <CENTER>
  <P>
    <IMG SRC="./Comp5.jpg">
    <H4>Figure 5</H4>
  </P>
  </CENTER>
  <P>
    Now we have two cases left.  When <I>ASign = '0'</I> and <I>BSign = '1'</I>
    we have <I>A</I> as a positive number and <I>B</I> as a negative number,
    meaning that <I>A</I> must be greater than <I>B</I> and our result is
    always going to be false.  This means that we don't care what the value 
    of <I>RSign</I> or <I>CarryOut</I> is.  Conversely, when <I>ASign = '1'</I>
    and <I>BSign = '0'</I> then <I>A</I> is negative and <I>B</I> is positive and
    <I>A</I> must be less than <I>B</I> so our result is always true.  This 
    is implemented in two lines of the table which have been added in Figure 6.
  </P>
  <CENTER>
  <P>
    <IMG SRC="./Comp6.jpg">
    <H4>Figure 6</H4>
  </P>
  </CENTER>
  <P>
    We have now completely specified the behavior of the table for <I>SLT</I>,
    or <I>ALUOp(1 DOWNTO 0)</I> = "10".  Check to see that by expanding the
    existing 6 lines of the table with don't cares you would get 16 lines.
  </P>
</LI>

<LI>
  <P>
    We have two lines left to fill in in the table which will specify the 
    last 16 cases and correspond to <I>ALUOp(1 DOWNTO 0)</I> = "11", or
    Set on Less than Unsigned.  Remember from above that we can test
    for <I>A < B</I> unsigned by performing an unsigned subtraction
    and checking for an overflow indicated by examining carry out from the
    most significant bit of the adder.  So, if we are performing 
    <I>SLTU</I> all we need to look at is the <I>CarryOut</I>
    signal.  If <I>CarryOut</I> = '1', then we did not have overflow,
    hence <I>A - B > 0</I> and we report FALSE.  If <I>CarryOut</I> = '0',
    then we have had an overflow and <I>A - B < 0</I> so we report TRUE.
    This has been implemented in the table in Figure 7.
  </P>
  <CENTER>
  <P>
    <IMG SRC="./Comp7.jpg">
    <H4>Figure 7</H4>
  </P>
  </center>
</LI>

<LI>
  <P>
    The <I>Comparison</I> sub-block is difficult to fully test in a stand-alone
    manner due to the fact that it requires the <I>Arithmetic</I> sub-block to
    function correctly.  However, it is also a relatively simple sub-block, so
    we will put off testing its functionality for now and verify that it works 
    correctly when we are simulating the entire <I>ALU</I>.
  </P>
</LI>

<LI>
  <P>
    Now that you have finished defining the last of the <I>Operation</I> sub-blocks,
    all that is left to complete the <I>ALU</I> is to <A HREF="../MuxBlock/ALU_MuxBlock.html">
    Fill in the Mux4B64 sub-block</A>.
  </P>
</LI>

    

</BODY>
</HTML>

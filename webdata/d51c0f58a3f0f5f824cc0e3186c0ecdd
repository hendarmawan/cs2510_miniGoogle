<HTML>
<HEAD><TITLE>Introduction to Operating Systems - Assignment #5</TITLE>
<script language="JavaScript">
<!--
function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_findObj(n, d) { //v4.0
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && document.getElementById) x=document.getElementById(n); return x;
}

function MM_nbGroup(event, grpName) { //v3.0
  var i,img,nbArr,args=MM_nbGroup.arguments;
  if (event == "init" && args.length > 2) {
    if ((img = MM_findObj(args[2])) != null && !img.MM_init) {
      img.MM_init = true; img.MM_up = args[3]; img.MM_dn = img.src;
      if ((nbArr = document[grpName]) == null) nbArr = document[grpName] = new Array();
      nbArr[nbArr.length] = img;
      for (i=4; i < args.length-1; i+=2) if ((img = MM_findObj(args[i])) != null) {
        if (!img.MM_up) img.MM_up = img.src;
        img.src = img.MM_dn = args[i+1];
        nbArr[nbArr.length] = img;
    } }
  } else if (event == "over") {
    document.MM_nbOver = nbArr = new Array();
    for (i=1; i < args.length-1; i+=3) if ((img = MM_findObj(args[i])) != null) {
      if (!img.MM_up) img.MM_up = img.src;
      img.src = (img.MM_dn && args[i+2]) ? args[i+2] : args[i+1];
      nbArr[nbArr.length] = img;
    }
  } else if (event == "out" ) {
    for (i=0; i < document.MM_nbOver.length; i++) {
      img = document.MM_nbOver[i]; img.src = (img.MM_dn) ? img.MM_dn : img.MM_up; }
  } else if (event == "down") {
    if ((nbArr = document[grpName]) != null)
      for (i=0; i < nbArr.length; i++) { img=nbArr[i]; img.src = img.MM_up; img.MM_dn = 0; }
    document[grpName] = nbArr = new Array();
    for (i=2; i < args.length-1; i+=2) if ((img = MM_findObj(args[i])) != null) {
      if (!img.MM_up) img.MM_up = img.src;
      img.src = img.MM_dn = args[i+1];
      nbArr[nbArr.length] = img;
  } }
}

function MM_displayStatusMsg(msgStr) { //v1.0
  status=msgStr;
  document.MM_returnValue = true;
}
//-->
</script>
</HEAD>

<BODY bgcolor=WHITE onLoad="MM_preloadImages('images/CMPS111NavBar_r1_c1_f3.gif','images/CMPS111NavBar_r1_c1_f2.gif','images/CMPS111NavBar_r1_c2_f3.gif','images/CMPS111NavBar_r1_c2_f2.gif','images/CMPS111NavBar_r1_c3_f3.gif','images/CMPS111NavBar_r1_c3_f2.gif','images/CMPS111NavBar_r1_c4_f3.gif','images/CMPS111NavBar_r1_c4_f2.gif','images/CMPS111NavBar_r1_c5_f3.gif','images/CMPS111NavBar_r1_c5_f2.gif')">
<hr>
<center>
  <table border="0" cellpadding="0" cellspacing="0" width="749">
    <!-- fwtable fwsrc="CMPS111NavBar.png" fwbase="CMPS111NavBar.gif" fwstyle="Dreamweaver" fwdocid = "742308039" fwnested="0" -->
    <tr> 
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="149" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="1" height="1" border="0" name="undefined_3"></td>
    </tr>
    <tr> 
      <td><a href="index.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Home Page');MM_nbGroup('over','CMPS111NavBar_r1_c1_2','images/CMPS111NavBar_r1_c1_f2.gif','images/CMPS111NavBar_r1_c1_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c1_2','images/CMPS111NavBar_r1_c1_f3.gif',1);" ><img name="CMPS111NavBar_r1_c1_2" src="images/CMPS111NavBar_r1_c1.gif" width="150" height="37" border="0"></a></td>
      <td><a href="homework.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Homework');MM_nbGroup('over','CMPS111NavBar_r1_c2_2','images/CMPS111NavBar_r1_c2_f2.gif','images/CMPS111NavBar_r1_c2_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c2_2','images/CMPS111NavBar_r1_c2_f3.gif',1);" ><img name="CMPS111NavBar_r1_c2_2" src="images/CMPS111NavBar_r1_c2.gif" width="150" height="37" border="0"></a></td>
      <td><a href="assignments.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Assignments');MM_nbGroup('over','CMPS111NavBar_r1_c3_2','images/CMPS111NavBar_r1_c3_f2.gif','images/CMPS111NavBar_r1_c3_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c3_2','images/CMPS111NavBar_r1_c3_f3.gif',1);" ><img name="CMPS111NavBar_r1_c3_2" src="images/CMPS111NavBar_r1_c3.gif" width="149" height="37" border="0"></a></td>
      <td><a href="exams.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Exams');MM_nbGroup('over','CMPS111NavBar_r1_c4_2','images/CMPS111NavBar_r1_c4_f2.gif','images/CMPS111NavBar_r1_c4_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c4_2','images/CMPS111NavBar_r1_c4_f3.gif',1);" ><img name="CMPS111NavBar_r1_c4_2" src="images/CMPS111NavBar_r1_c4.gif" width="150" height="37" border="0"></a></td>
      <td><a href="slides.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Slides');MM_nbGroup('over','CMPS111NavBar_r1_c5','images/CMPS111NavBar_r1_c5_f2.gif','images/CMPS111NavBar_r1_c5_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c5','images/CMPS111NavBar_r1_c5_f3.gif',1);" ><img name="CMPS111NavBar_r1_c5" src="images/CMPS111NavBar_r1_c5.gif" width="150" height="37" border="0"></a></td>
      <td><img src="images/spacer.gif" width="1" height="37" border="0" name="undefined_3"></td>
    </tr>
  </table>
</center>
<hr>
<p>

<center>
  <H1>CS 1550: Introduction to Operating Systems</H1>

  <h2>Programming Assignment #5: NachOS File System Extensions</h2>

Due Date: Monday April 24, 2006 - 9:00am <b>(no extensions, no grace
period)</b>
</center>

<hr>
<center>
<em>In this assignment you will be asked to complete the functionality
provided by the NachOS file system code. Specifically you will mainly
be working with the code and nachos executable in the code/filesys
directory.
You do not need any prior assignment to strat and complete this
one (and so you should start with the provided code).
</em>
</center>

<h3>Group Work</h3>
Individuals working alone will recieve a 10% bonus.  However, in order
to incease your odds of success I recommend working in a pair.  Groups
of two will neither be rewarded nor punished.  If you are looking for
a partner, send me an email, and I will pair you with someone else who
also wants to work in a group.  Groups of 3 are permitted as well,
but will be required to complete one of the optional parts in addition to the
three required parts.<P>
Email me you group composition by Friday the 14th.
<p>
<h3>Submission Details</h3>

Again you will be modifying several source files, and to submit your
assignment you will copy your files to a directory called
<em>cs1550-submit/assign5</em> under your home directory. Be sure to 
only allow access for the TAs and instructors (mosse and jalst114), not the world. 
Also, create a symbolic link called <em>code</em>
(~/cs1550-submit/code) which points to your local copy of nachos.

<p> 
It is <b>VERY VERY</b> important that you document your solution well. All
code must be well documented, but you must also <b>list modified files</b>,
describe any assumptions you make, and how you chose to solve the
problem.
We will look for this high-level information in a a file you should
call README.TXT
<p>

<hr>		


<h2>The Basics</h2>



The multiprogramming and virtual memory assignments made use
of the Nachos file system.
The fourth phase of Nachos is to actually build this file system.
As in the first two assignments, we give you some of the code
you need; your job is to complete the file system and enhance it.

The first step is to read and understand the partial file system
we have written for you.  
Run the program `nachos -f -cp test/small small' for a simple test case
of our code -- `-f' formats the emulated physical disk, and `-cp'
copies the UNIX file `test/small' onto that disk.

<p>
The files to focus on are:
<p>
<table>

<tr valign="top">
<td><em>fstest.cc</em></td> 
<td> - a simple test case for our file system.</td></tr>

<tr valign="top">
<td><em>filesys.h, filesys.cc</em></td>
<td> - top-level interface to the file system.</td></tr>

<tr valign="top">
<td><em>directory.h, directory.cc</em></td>
<td> - translates file names to disk file headers; 
the directory data structure is stored as a file.</td></tr>

<tr valign="top">
<td><em>filehdr.h, filehdr.cc</em></td>
<td> - manages the data structure representing
the layout of a file's data on disk.</td></tr>

<tr valign="top">
<td><em>openfile.h, openfile.cc</em></td>
<td> - translates file reads and writes to
disk sector reads and writes.</td></tr>

<tr valign="top">
<td><em>synchdisk.h, synchdisk.cc</em></td>
<td> - provides synchronous
access to the asynchronous physical disk, so that threads block until 
their requests have completed.</td></tr>

<tr valign="top">
<td><em>disk.h, disk.cc</em></td>
<td>  - emulates a physical disk, by sending requests 
to read and write disk blocks to a UNIX file and then generating 
an interrupt after some period of time.
The details of how to make read and write requests varies tremendously
from disk device to disk device; in practice, you would want to hide 
these details behind something like the abstraction provided 
by this module.</td></tr>

</table>


<p>
Our file system has a UNIX-like interface, so you may also wish to read 
the UNIX man pages for creat, open, close, read, write, lseek, and unlink
(e.g., type ``man creat'').  
Our file system has calls that are similar (but {\em not} identical) to these;
the file system translates these calls 
into physical disk operations.  One major difference is that our 
file system is implemented in C++.  Create (like UNIX creat), 
Open (open), and Remove (unlink) are defined on the FileSystem object, 
since they involve manipulating file names and directories.  
FileSystem::Open returns a pointer to an OpenFile object, 
which is used for direct file operations such as Seek (lseek), Read (read),
Write (write).  An open file is ``closed'' by deleting the OpenFile object.

<p>
Many of the data structures in our file system are
stored both in memory and on disk.  To provide some uniformity,
all these data structures have a ``FetchFrom'' 
procedure that reads the data off disk and into memory,
and a ``WriteBack'' procedure that stores the data back to disk.
Note that the in memory and on disk representations do not have
to be identical.

<p>
While the provided code implements all the major pieces of a file system, it
has some limitations.  Your job will be to fix these limitations.


<hr>

<h2>The Specifics</h2>


<h3>Part 1 (required) - Support Larger Files</h3>

Modify the file system to allow the maximum size of a file to be as large 
as the disk (128Kbytes).  In the basic file system, each file is limited 
to a file size of just under 4Kbytes.  Each file has a header 
(class FileHeader) that is a table of direct pointers to the disk blocks 
for that file.  Since the header is stored in one disk sector, the 
maximum size of a file is limited by the number of pointers that will 
fit in one disk sector.  Increasing the limit to 128KBytes will probably
but not necessarily require you to implement doubly indirect blocks.

<em><b>Hint:</b> think of indirect and direct blocks.</em>


<h3>Part 2 (required) - Synchronization</h3>

Complete the basic file system by adding synchronization to
allow multiple threads to use file system concurrently.  Currently,
the file system code assumes it is accessed by a single thread at a time.
In addition to ensuring that internal 
data structures are not corrupted, your modified file system must 
observe the following constraints (these are the same as in UNIX):

<p>

<li> The same file may be read/written by more than 
one thread concurrently.  Each thread separately opens the file,
giving it its own private seek position within the file.  
Thus, two threads can both sequentially read through the same file
without interfering with one another.</li>

<li> All file system operations must be atomic and serializable.
For example, if one thread is in the middle of a file write,
a thread concurrently reading the file will see either all of the change or
none of it.  Further, if the OpenFile::Write operation finishes
before the call to OpenFile::Read is started, the Read {\em must} reflect
the modified version of the file.</li>

<li> When a file is deleted, threads with the file already open 
may continue to read and write the file until they close the file.
Deleting a file (FileSystem::Remove) must prevent further opens on 
that file, but the disk blocks for the file cannot be reclaimed 
until the file has been closed by all threads that currently have the 
file open.</li>

<p>

<em><b>Hint:</b> to do this part, you will probably find you need to maintain 
a table of open files.</em>


<h3>Part 3 (required) - Dynamic File Extension</h3>

Implement extensible files.  In the basic file system, the file
size is specified when the file is created.  One advantage of this
is that the FileHeader data structure, once created, never changes.
In UNIX and most other file systems, a file is initially created
with size 0 and is then expanded every time a write is made off the
end of the file.  Modify the file system to allow this; as one test
case, allow the directory file to expand beyond its current limit
of ten files.  In doing this part, be careful that concurrent 
accesses to the file header remain properly synchronized.



<h3>Part 4 (optional/bonus) - Improve File System Performance</h3>

Improve the performance of your file system.  
Recompile Nachos with the -DREALISM flag, and use as your
performance metric the number of ticks needed to run 
the test case in test4.cc (run `nachos -t').
The test case in test4.cc sequentially reads and writes a large file.

<p>
Here are a couple of approaches you might take to improving performance:

<p>

<li> Optimize disk seek and rotational latency.  To read or write
a sector, the disk head must be moved to the correct track
and then the system must wait for the correct sector to rotate
under the disk head.  In disk-bound systems, these delays can
be a cause of poor performance.  This can be fixed by (i)
laying disk blocks from the same file on the same track 
(cf. article by McKusick et al.) and (ii)
when multiple requests are queued for the disk, scheduling first
those that would have the shortest delay, while at the same
time avoiding starvation of disk requests.</li>


<li> Modify the file system to keep a cache of file blocks.  
When a request is made to read a block, check to see if it is stored 
in the cache, and 
if so, no disk access is needed since a copy can be returned immediately.
One enhancement is that instead of always immediately writing modified 
data to disk, dirty blocks can be kept in the cache and written out 
sometime later --- this is called ``write-behind''.
Another enhancement is to
automatically fetch the next block of a file into the cache, when one 
block of a file is read, in case that block is about to be read ---
this is called ``read-ahead.''
You are limited to a cache that is 64 disk sectors in size (roughly 6%
of the size of the disk); this space limit must include the memory you
use for open files, the bitmap, etc., if you keep those in memory.</li>

<p>
For each of these you implement, explain what you expect the
performance improvement to be on the benchmarks, and why
the other alternatives (the ones you did not implement) would yield
fewer performance gains for the same effort.

<h3>Part 5 (optional/bonus) - Directories Anyone?</h3>

Implement a hierarchical name space.  In the basic file system,
all files live in a single directory; modify this to allow
directories to point to either files or other directories.
To do this you will need routines to parse path names into
the sequence of directories where to find the file.
You will also need to implement routines to change the 
current working directory (cf. the UNIX `cd' command) and to 
print the contents of the current directory.

For performance, allow concurrent updates to different directories,
but use mutual ensure that updates to the same directory directory
are performed atomically (for example, to ensure that a file is
deleted only once).



<h3>Part 6 (optional/bonus) - fsck for Nachos</h3>

The Nachos disk may be corrupted if the system does not 
exit cleanly (e.g., after a crash due
to a software bug or if you exit from gdb without finishing the program).
This is because some file system operations require more than one
physical disk write.  One example is creating a new file, which requires
writing a new FileHeader to disk as well as updating the directory 
and the bit map of free blocks.  If the system crashes after having
done some but not all of these updates, the disk may be in an inconsistent
state.  For extra credit, design reliability into your file system.

You can address this in one of two ways.  One approach is to 
log when you begin and finish a sequence of logically atomic 
writes (cf. the Gray article).  Another is to structure the file
system so that each update takes effect with the write of a single disk block.
For instance, to modify a file, you can write the modifications
to new disk blocks, overwrite the FileHeader to point to those blocks,
and then put the old blocks back on the free list.  Note that
the free list may be redundant; it may be able to be reconstructed after
a crash from the other data on the disk.  

If it helps, you may assume (somewhat unrealistically) that crashes occur 
either before or after, but not during disk writes.  In other
words, a disk sector will contain either the old value or the new
value, but not part of each.

For this part, you should test your system by crashing it at an
inopportune point (eg, in the middle of a directory update), and 
then reconstruct the disk after the crash.

<hr>

  <table width=100%>
    <tr>
      <td>
      <td>
        <center>
          <EM> This assignment is lightly adapted from NachOS' assignmnet 4 by Tom Anderson.
          </EM>
        </center>
      <td>
    </tr>
  </table>



</BODY>
</HTML>

<HTML>
<HEAD><TITLE>Introduction to Operating Systems - Assignment #3</TITLE>
<script language="JavaScript">
<!--
function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_findObj(n, d) { //v4.0
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && document.getElementById) x=document.getElementById(n); return x;
}

function MM_nbGroup(event, grpName) { //v3.0
  var i,img,nbArr,args=MM_nbGroup.arguments;
  if (event == "init" && args.length > 2) {
    if ((img = MM_findObj(args[2])) != null && !img.MM_init) {
      img.MM_init = true; img.MM_up = args[3]; img.MM_dn = img.src;
      if ((nbArr = document[grpName]) == null) nbArr = document[grpName] = new Array();
      nbArr[nbArr.length] = img;
      for (i=4; i < args.length-1; i+=2) if ((img = MM_findObj(args[i])) != null) {
        if (!img.MM_up) img.MM_up = img.src;
        img.src = img.MM_dn = args[i+1];
        nbArr[nbArr.length] = img;
    } }
  } else if (event == "over") {
    document.MM_nbOver = nbArr = new Array();
    for (i=1; i < args.length-1; i+=3) if ((img = MM_findObj(args[i])) != null) {
      if (!img.MM_up) img.MM_up = img.src;
      img.src = (img.MM_dn && args[i+2]) ? args[i+2] : args[i+1];
      nbArr[nbArr.length] = img;
    }
  } else if (event == "out" ) {
    for (i=0; i < document.MM_nbOver.length; i++) {
      img = document.MM_nbOver[i]; img.src = (img.MM_dn) ? img.MM_dn : img.MM_up; }
  } else if (event == "down") {
    if ((nbArr = document[grpName]) != null)
      for (i=0; i < nbArr.length; i++) { img=nbArr[i]; img.src = img.MM_up; img.MM_dn = 0; }
    document[grpName] = nbArr = new Array();
    for (i=2; i < args.length-1; i+=2) if ((img = MM_findObj(args[i])) != null) {
      if (!img.MM_up) img.MM_up = img.src;
      img.src = img.MM_dn = args[i+1];
      nbArr[nbArr.length] = img;
  } }
}

function MM_displayStatusMsg(msgStr) { //v1.0
  status=msgStr;
  document.MM_returnValue = true;
}
//-->
</script>
</HEAD>

<BODY bgcolor=WHITE onLoad="MM_preloadImages('images/CMPS111NavBar_r1_c1_f3.gif','images/CMPS111NavBar_r1_c1_f2.gif','images/CMPS111NavBar_r1_c2_f3.gif','images/CMPS111NavBar_r1_c2_f2.gif','images/CMPS111NavBar_r1_c3_f3.gif','images/CMPS111NavBar_r1_c3_f2.gif','images/CMPS111NavBar_r1_c4_f3.gif','images/CMPS111NavBar_r1_c4_f2.gif','images/CMPS111NavBar_r1_c5_f3.gif','images/CMPS111NavBar_r1_c5_f2.gif')">
<hr>
<center>
  <table border="0" cellpadding="0" cellspacing="0" width="749">
    <!-- fwtable fwsrc="CMPS111NavBar.png" fwbase="CMPS111NavBar.gif" fwstyle="Dreamweaver" fwdocid = "742308039" fwnested="0" -->
    <tr> 
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="149" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="150" height="1" border="0" name="undefined_3"></td>
      <td><img src="images/spacer.gif" width="1" height="1" border="0" name="undefined_3"></td>
    </tr>
    <tr> 
      <td><a href="index.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Home Page');MM_nbGroup('over','CMPS111NavBar_r1_c1_2','images/CMPS111NavBar_r1_c1_f2.gif','images/CMPS111NavBar_r1_c1_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c1_2','images/CMPS111NavBar_r1_c1_f3.gif',1);" ><img name="CMPS111NavBar_r1_c1_2" src="images/CMPS111NavBar_r1_c1.gif" width="150" height="37" border="0"></a></td>
      <td><a href="homework.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Homework');MM_nbGroup('over','CMPS111NavBar_r1_c2_2','images/CMPS111NavBar_r1_c2_f2.gif','images/CMPS111NavBar_r1_c2_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c2_2','images/CMPS111NavBar_r1_c2_f3.gif',1);" ><img name="CMPS111NavBar_r1_c2_2" src="images/CMPS111NavBar_r1_c2.gif" width="150" height="37" border="0"></a></td>
      <td><a href="assignments.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Assignments');MM_nbGroup('over','CMPS111NavBar_r1_c3_2','images/CMPS111NavBar_r1_c3_f2.gif','images/CMPS111NavBar_r1_c3_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c3_2','images/CMPS111NavBar_r1_c3_f3.gif',1);" ><img name="CMPS111NavBar_r1_c3_2" src="images/CMPS111NavBar_r1_c3.gif" width="149" height="37" border="0"></a></td>
      <td><a href="exams.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Exams');MM_nbGroup('over','CMPS111NavBar_r1_c4_2','images/CMPS111NavBar_r1_c4_f2.gif','images/CMPS111NavBar_r1_c4_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c4_2','images/CMPS111NavBar_r1_c4_f3.gif',1);" ><img name="CMPS111NavBar_r1_c4_2" src="images/CMPS111NavBar_r1_c4.gif" width="150" height="37" border="0"></a></td>
      <td><a href="slides.html" onMouseOut="MM_nbGroup('out');"  onMouseOver="MM_displayStatusMsg('Slides');MM_nbGroup('over','CMPS111NavBar_r1_c5','images/CMPS111NavBar_r1_c5_f2.gif','images/CMPS111NavBar_r1_c5_f3.gif',1);return document.MM_returnValue"  onClick="MM_nbGroup('down','navbar1','CMPS111NavBar_r1_c5','images/CMPS111NavBar_r1_c5_f3.gif',1);" ><img name="CMPS111NavBar_r1_c5" src="images/CMPS111NavBar_r1_c5.gif" width="150" height="37" border="0"></a></td>
      <td><img src="images/spacer.gif" width="1" height="37" border="0" name="undefined_3"></td>
    </tr>
  </table>
</center>
<hr>
<p>

<center>
  <H1>CS 1550: Introduction to Operating Systems</H1>

  <h2>Programming Assignment #3: <br>
Synchronization through The Office Hours Program and the Laundromat Problem</h2>

Due Date: Wednesday, February 15, 2006 by 11:59 pm
<!--Monday October 2 or 6, 2003 (See EXTENSION information below)-->
</center>

<hr>
<center>
<em>In this assignment you will be asked to implement a multi-threaded program
under NACHOS. This will give you a chance to apply what you have learned about
synchronization.
This particular assignment was taken from the NACHOS programming assignments provided
by Tom Anderson.
</em>
</center>

<p>
<h3>Submission Details</h3>


You will be modifying the threadtest source file in the <em>threads</em>
directory. To submit your file(s), follow the instructions given in
<a href = "handin.html">handin.html</a>. <!--For this assignment, submit
the files that you have modified and also provide us with a symbolic
link called <em>code</em> (~/public/cs1550/submit/code) which points
to your local copy of Nachos.-->

<p> 
It is <b>very</b> important that you document your solution well. All
code must be very well documented, but you must also describe any
assumptions you make, and how you chose to solve the problem. The solution 
description, and assumptions should be provided in a seperate README file.
<p>

<hr>

<h3>Preliminaries</h3>

In this assignment, we give you part of a working thread system; 
your job is to complete it, and then to use it to solve
several synchronization problems.  

The first step is to read and understand the partial thread system 
we have written for you.  This thread system implements thread fork, 
thread completion, along with semaphores for synchronization.  
Run the program `nachos' for a simple test of our code.
Trace the execution path (by hand) for the simple test case
we provide.

When you trace the execution path, it is helpful to keep track
of the state of each thread and which procedures are on each thread's 
execution stack.
You will notice that when one thread calls SWITCH, another thread
starts running, and the first thing the new thread does is 
to return from SWITCH.
We realize this comment will seem cryptic to you at this point, but you
will understand threads once you understand
why the SWITCH that gets called is different from the SWITCH that returns.
(Note: because gdb does not understand threads, you will get bizarre 
results if you try to trace in gdb across a call to SWITCH.)

The files for this assignment are:

<ul>

<li> main.cc, threadtest.cc --- a simple test of our thread routines.

<li> thread.h, thread.cc --- thread data structures and
thread operations such as thread fork, thread sleep and thread finish.

<li> scheduler.h, scheduler.cc --- manages the list of threads that
are ready to run.

<li> synch.h, synch.cc --- synchronization routines: semaphores, locks, 
and condition variables.

<li> list.h, list.cc --- generic list management (LISP in C++).

<li> synchlist.h, synchlist.cc --- synchronized access to lists using
locks and condition variables (useful as an example of the use 
of synchronization primitives).

<li> system.h, system.cc --- Nachos startup/shutdown routines.

<li> utility.h, utility.cc --- some useful definitions and debugging routines.

<li> switch.h, switch.s --- assembly language magic for starting 
up threads and context switching between them.

<li> interrupt.h, interrupt.cc --- manage enabling and disabling
interrupts as part of the machine emulation.

<li> timer.h, timer.cc --- emulate a clock that periodically causes 
an interrupt to occur.

<li> stats.h -- collect interesting statistics.

</ul>


<h3>The Basics</h3>

Properly synchronized code should work no matter what order the 
scheduler chooses to run the threads on the ready list.  In other 
words, we should be able to put a call to "sleep" (in nachos it should
be Thread::Yield) (causing the scheduler
to put this thread to sleep and choose another thread to run) anywhere
in your code where interrupts  
are enabled without changing the correctness of your code.   
You will be asked to write properly synchronized code as part of the 
later assignments, so understanding how to do this is crucial to
being able to do the project.
<p>
To aid you in this, code linked in with Nachos will cause Thread::Yield 
to be called on your behalf in a repeatable but unpredictable way.
Nachos code is repeatable in that if you call it repeatedly with the 
same arguments, it will do exactly the same thing each time.
However, if you invoke ``nachos -rs #'', with a different number each
time, calls to Thread::Yield will be inserted at different places in the code.
<p>
Make sure to run various test cases against your solutions to 
these problems; for instance, for part two, create multiple producers
and consumers and demonstrate that the output can vary, within certain 
boundaries.
<p>

Warning: in our implementation of threads, each thread is assigned a 
small, fixed-size execution stack.  This may cause bizarre problems 
(such as segmentation faults at strange lines of code) if you declare 
large data structures to be automatic variables (e.g., ``int buf[1000];'').
You will probably not notice this during the semester, but if you do,
you may change the size of the stack by modifying the StackSize define in 
switch.h.
<p>

The solutions can be written as normal C or C++ routines, even though we
will be using the NACHOS C++ environment.  Your solutions should be
deadlock free, starvation free, and fair.  You are supposed to hand in (in the README file)
a small written justification of why this is true.  Also, there should be no
busy-waiting in any of your  solutions to this assignment.  


<h3>The Problems</h3>

<ol>

<li>You have been hired by the CS Division to write code to help
synchronize a professor and his/her students during office hours.
The professor, of course, wants to take a nap if no students are around to
ask questions; if there are students who want to ask questions,
they must synchronize with each other and with the professor so that
<ul>
<li> only one person is speaking at any one time, 
<li> each student question is answered by the professor, and
<li> no student
asks another question before the professor is done answering the previous
one. 
</ul>
 You are to write four procedures: <i> AnswerStart(), AnswerDone(),
QuestionStart()</i> , and <i> QuestionDone()</i>.
<p>

The professor loops running the code: AnswerStart(); give answer; AnswerDone().
AnswerStart doesn't return until a question has been asked.
Each student loops running the code: QuestionStart(); ask question; 
QuestionDone().  QuestionStart() does not return until it is the student's 
turn to ask a question.   Since professors consider it rude for a student
not to wait for an answer, QuestionEnd() should not return until the
professor has finished answering the question.

<li>The local laundromat has just entered the computer age.  As each
customer enters, he or she puts coins into slots at one of two
stations
and types in the number of washing machines he/she will need.  The
stations are connected to a central computer that automatically
assigns
available machines and outputs tokens that identify the machines to be
used.  The customer puts laundry into the machines and inserts each
token into the machine indicated on the token.  When a machine
finishes
its cycle, it informs the computer that it is available again.  The
computer maintains an array <i>available[NMACHINES]</i> whose elements
are non-zero if the corresponding machines are available (NMACHINES is
a
constant indicating how many machines there are in the laundromat),
and
a semaphore <i>nfree</i> that indicates how many machines are
available.

<p>The code to allocate and release machines is as follows:

<pre>
int allocate()/* Returns index of available machine.*/
{
  int i;

  P(nfree);/* Wait until a machine is available */
  for (i=0; i &lt; NMACHINES; i++)
    if (available[i] != 0) {
      available[i] = 0;
      return i;
    }
}

release(int machine)/* Releases machine */
{
  available[machine] = 1;
  V(nfree);
}
</pre>

The <i>available</i> array is initialized to all ones, and
<i>nfree</i>
is initialized to NMACHINES.

<ol>

<li>It seems that if two people make requests at the two stations at
the
same time, they will occasionally be assigned the same machine.  This
has resulted in several brawls in the laundromat, and you have been
called in by the owner to fix the problem.  Assume that one thread
handles each customer station.  Explain how the same washing machine
can
be assigned to two different customers.

<li>Modify the code to eliminate the problem.

<!--<li>Re-write the code to solve the synchronization problem using locks
and condition variables instead of semaphores.-->

<li> you must implement a runnable version of the laundromat for NachOS.
</ol>
</ol>

<h3>What you need to do, AND WHEN!</h3>


You need to write a NACHOS program that fully implements the
above problems. You will use the NACHOS source tree (hopefully
you are now familiar with it), and will submit the source for
your solution as previously specified (timestamps will be checked
to verify last modification times).

<p>
For full credit, on <b>February 15, 2006</b>, the code must be finalized, and 
not modified after that. 

</BODY>
</HTML>

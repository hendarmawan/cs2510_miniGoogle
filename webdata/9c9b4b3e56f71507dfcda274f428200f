     PROFESSOR:   This is medium bird.
(extra bonus for people turning in project
this week.) This is not early bird.  I
have another announcement.  Medium is by
Thursday this week and has to be before
class.  I got ten assignments last week
for early bird and nobody got below ten
points.
     That will still be bonus points.  If
you can't finish today, try to finish by
Thursday you will still get one point.
How's that?  Yeah?
     STUDENT:   Question about the
project.  On standard web based
installation it collects a folder called
HTTP.  And that is where it looks to by
default when it goes from one form to the
next.  The computer that you have, do you
have web base installed that way according
to standard installation?  Yeah.
     PROFESSOR:   Yeah.
     STUDENT:   In other words, if we give
you a floppy you can copy to the HTTp and
it should work?
     PROFESSOR:   Exactly.  Your top page
must be default HTF.  The top page.  In
other words if you start off with HTF form
that should be your top page.  But of
course, you can start out with anything.
You can start out with HTML.
     STUDENT:   Right.
     PROFESSOR:   This will -- the HTF
pages.  Right?
     STUDENT:   Well, default to HTF.
     PROFESSOR:   If you have first page
then you link to other pages.  You can do
it that way.
     STUDENT:   They said don't give it
HTF unless it has the other code imbedded.
     PROFESSOR:   Your top page can be
HTML or if you prefer to start off with
web base page it should be like this.
     STUDENT:   Your first page it gives
you a choice to branch to search or that
could be the welcome?
     PROFESSOR:   Yeah.  Yeah?  Any other
questions?
     STUDENT:   If we hand in disk -- if
we bring in a disk with the files that go
on HTTP, directory, does that mean we
don't have to bring in our PC?
     PROFESSOR:   You can do either way.
But the safe way toys bring your own note
book, in way nothing can go wrong.  Today
we inspected two projects.  One actually,
he implemented his own server so I just
dial in.  That's cool.  So he doesn't have
to come here.  You can do the same.  If
your PC is a server, you can give me it
and test it remotely.  You still have to
hand me hard copy on diskette offer or
bring in notebook, and she just did it
that way, that's cool as well.  Then the
third choice toys bring in diskette.  We
will upload on to my computer and try it
that way.  But that, there is always
taking a chance.  We cannot guarantee
everything work, right?  So that's, --
yeah.  Any other questions?  So far I
think we're doing fine.  So far is that we
have eight for project one and two for
project two.  But I'm not surprised
because normally the project one will
complete earlier and project two will
complete later.
     Now do you lose three bonus points?
Yes, but on the other hand you learn a lot
by putting everything together.  So it's a
tradeoff.  I mention about -- yeah.  The
medium bird, that will be Thursday and
then someone mentioned if you bring up
your project to show up at computer
science day you get credit?  Yeah a little
bi.  I give everybody half a point if you
show off your project on computer science
day.  That's a good idea.  It's a little
bit.  It's a token, but still.
     Okay.  Exercise.  So we are going to
spend the last two days, sorry, the last
two lectures this week trying to wrap up
everything and giving you perspective and
methodology for database design.
Question?
     STUDENT:   You were talking, was it
last week, about chapters 11 and 12.  Was
there only certain sections?
     PROFESSOR:   Yes, definitely.  This
was the last week we talk about database
design.  Next Tuesday, as usual, we did a
review and I it will you what sections
we'll cover.  But of course, I will post
it on web page first because next Tuesday
and Thursday I give -- you will not read
whole chapter but selected sections that
are related to my lectures.  So, again,
just a general idea.  You know, how to
prepare the final, so you notice that
first half before the midterm is more
quantitative.  Second half is more hands
on.  Hands phone for you for the project
and for conceptual.  So, I'm going to
steer -- first part before the midterm,
same as you would expect, so half of the
problems, half credit will be from the
first half and the second half will be
more conceptual, more multiple choice, yes
or no, this type of thing.  As for web
base, concept only, CGI, web based
concept.  CGI.  I won't test you on the
programming part.
     Now the -- now that we have done the
exercises and also you guys are doing a
very good job on the project, so now we
can sit back, while you sit back and
relax, but then we can talk about the
whole business of database design.  Can I
have the lights off?  Let's turn off
everything.  Okay.  Okay.  Now what we did
in is class is first you had a lot of
hands-on.  Now you are in a position if
you choose web base project to put
together online database system.  And then
we also cover some theoretical component.
Now these components are not chosen
without reason.  They are supposed to fit
together so you can see what we need to go
through, all of the steps.  You can say
that you can just go out and start from
scratch by using oracle to view the
database, but still it's better to have a
methodology.  So this is basically the
outline of this methodology.  First we
start from the user end.  Remember you
always start from the user by asking about
their requirements and we try to capture
their requirements using a semantic model.
The one that I taught you is the entity
relationship model.  The newer one is UML,
universal modeling language.  We also talk
about that. but for the sake of designing
database, we do not need a full power of
UML but at least you should note sub part,
the part we cover, how do you define a
class diagram, how do you define a object
diagram.  In fact, both can be captured
using ER diagram, extend ER diagram.  So
this is the first thing.  When you start
with the database, you capture the user's
requirements using the ER diagram.
     Second, once we have the ER diagram,
then we can argue, looking at the
relationship between the entities whether
they should be many to one, one to one,
one to many.  Or many to many.  Now, the
significance of this step is that once you
go through this exercise, you know pretty
sure what are the keys and what are the
foreign keys.  What's the significance of
foreign keys?  Why we talk about foreign
key?  What is the foreign key?  Yeah?
     STUDENT:   It's a key of a table that
relates over to like another table so if
you have like a relation of students and
what classes they're in, your foreign keys
might be their SSN in one table and that
links over to like a table student which
has its main key is SSN which will give
you all the other information.  In other
words we can use that to link the
relations, link the tables.  By having the
foreign keys, foreign keys, use the
analogy, prince in his kingdom but when he
travels he becomes attribute in another
kingdom, so by following the foreign key,
like he just mentioned, you link and get
other information.  The database is trying
to access information, right?  And it's
possible only if you can combine
information from many tables or many
classes if you use the object Oriented
model.  So, by looking at the
relationship, okay?  We have a good idea
what should be keys and what should be
foreign keys.  That's why in project one I
asked you to implement many of you asked
me question, what kind of join should we
implement?  I keep on answering, you can
do the join by the key.  That's already a
big step.  Why?  Because that's what we
usually do.  You seldom see people join by
say sex or join -- yeah, people join by
sex.  I don't mean a pun but okay.  You
don't join by gender, that's more neutral.
So because that's too constant.  So you
have to choose something.
     So we come up with ER diagram, we
analyze that and then we can draw the
so-called dependency graph the dependency
graph, what does it tell us?  These are
the kind of conceptual questions I will be
interested in asking.
     STUDENT:   Tells us what attributes
are dependent on keys.
     PROFESSOR:   So if i write down for
exam, SSN, arrow to name, what does this
tell us?
     STUDENT:   Tells us the name can be
uniquely determined by the social security
number.
     PROFESSOR:   Right.  In other words
if have you this diagram, like you said
earlier, we can analyze the diagram, and
determine who are the keys, what are the
keys.  That's one thing.  What's the other
use of the dependency graph?
     STUDENT:   If your database is
normalized or not?
     PROFESSOR:   Right.  This is where we
can clear up analysis to see if forms are
first normal form, second normal form,
third normal form.  And we like to have
third formal form because?
     STUDENT:   Anomalies.
     PROFESSOR:   Because we can avoid
update anomalies.  We look into those.  If
we have first normal form when we update,
either when I delete something and some
hidden information hidden relationship is
gone, all I want -- or I want to add
something but I cannot add to it because I
don't have appropriate primary key.  There
are problems but if we reduce from the
first or second normal form into third
normal form, then those problems can be
avoided.  So the dependency graph,
dependency diagram is important, first of
all, we Kana certain what should be the
keys of various relation.  That's not to
say you always insist that. later on you
encounter situations that for some reason,
maybe the user like it that way, because
of existence of legacy system, you have to
keep the table intact, that's a big table.
If you analyze that, it's in violation of
third normal form.  Okay?  Have you to
live with that.  This okay.  As long as
you know the Kong sequence.  In other
words, then have you to be very careful
when you design the update programs so
that you can keep the information you want
to keep and be able to add information you
want to add.  But going through this whole
sequence, you go through relations,
decomposed relations and each one in the
graph corresponds to a single third normal
form relation.  So, starting from ER
diagram, we analyze their relationships,
come up with the dependency graph, use
that as a strategy for decomposition, to
design database.  We all note real work is
not that perfect. -- the real world is not
that perfect.  This give you a very good
framework.  So think about database
design.  Even if you don't carry out
everything in this methodology.  It still
worth considering.
     Okay.  So now I will use a very
trivial example.  To go these steps of
database design.  So that you know what I
mean.  Now like I said, first we want to
talk to the user to get the requirements.
Now, normally the user's requirements are
in words.  So when you do a design,
following some kind of software
enginerring methodology the user
requirements are usually not coded to the
program or program but it's expressed in
words.  But sometimes if we can then we
can try to express that into semantic
network or conceptual graph.  If you have
a database for some company and we have
concept of employee, so employee has ID,
salary and reports to a manager who is
also employee.  So the conceptual graph is
that employee has ID, ID has a salary, and
employee reports it a manager and manager
is employee.  You can capture that using
the so-called extended ER diagram.  This
relationship.  And then come up with a
design, for example you have ER diagram,
we have entity called employee and ID the
salary and manager becomes their
attributes so if you look at dependency
diagram, then ID is the key.  It
determines the salary, ID determines the
manager.  This diagram, if you draw it,
it's already in the third normal form.  So
we can express that as a single database
schema.  Now the thing that's worth noting
for this database schema is that manager
is a foreign key, right?  Now, because we
use manager then we can link employee to
this relation itself to find out who is
this employee, so that is where we can
perform the links.  This is a very simple
example, you end up with only one
relation.  Usually the situation is more
complex than that.  But normally, when you
start designing database there are always
some relations that just come up, without
any questions, like library information
system, some of you have been working on.
There is no question that I have though
make relation for books.  There is no
question I have to make a relation for
users.  And there is no question we have
to make relation for circulation.  Right?
Because if you think about the purpose of
the library, what do you have in you have
books, these are resources, have you users
and users can borrow or return books,
that's circulation.
     So that's like the back bone and then
we build on of it and then we can
construct the schema.  So we talk about
the ER methodology.  You should know that
by heart and how to express ER diagram
graphically and we talked about dependency
graph, how to decompose it and how to come
up with third normal form.
     Okay.  So, we talk about relational
approach, network approach, hierarchical
approach and object Oriented approach.
Not on slide but in the note you have
that.  The final question is that we show
you that we can draw ER diagram and then
from the ER diagram we can design other
stuff.  Can we do that for all database
models?  Namely, if I give you an ER
diagram, from this ER diagram how do we
design relational database, network
database, hierarchical database, object
Oriented database?  If it is possible,
then it's great, because then once I draw
the ER diagram, we can come up with
database, and the answer obviously is yes,
we can do that.  So, what we'll do today
is to show by examples, how we can design
relation database using the ER model and
then on Thursday, we'll talk about the
other models.  Now we can have the lights.
     So we'll start by looking at first of
all, trivial examples, and then less
trivial examples.  Now.  We'll use library
database because now we are quite familiar
with it.  So we have users and books and
the purpose of the library is of course to
serve the user.  Well, in a library jargon
we call this patron.  These are the people
who will visit the library and be able to
get some service.  Okay.  So like I said,
first we capture the semantics.  We know
they are the concept of books, concept of
users and book loan.  And then we try to
draw the attributes.  So book has ISBN
number.  And user has user ID.  A secure
number.  Then the user can loan books, so
one question that we have to ask is, what
is this?  One to one?  One to many, many
to many?
     STUDENT:   One user can borrow many
books.
     PROFESSOR:   Okay.
20 A     So, can one book be shared by many users?  No.
Not in usual library model.  So one to many.
Okay.  Now let's just have for simplistic we
have this, so book has ISBN number and title.
And the user has user ID and name.  And then
on a certain date, date of loan we have a date
of checking out and then a date of return and
finally we have a file.  Something like that.
it's one to many, so one user can borrow many
books.  Questions?  Suppose I want to realize
it in relational database?  What do I do?  Do
I realize that one table?  Two, three,
whatever?  What do you think?
     STUDENT:   Three different ones?
     PROFESSOR:   Three different ones.
Okay.  How?
     STUDENT:   One for books, one for
loan and one for users.
     PROFESSOR:   Okay.  One for books, so
I have ISBN number as the key, right?
Title.  One for user., Here I have user ID
and name.  That's obvious, you take an
entity and make it a relation.  How about
a third one?  Do the same thing but use
ISBN and user ID as key.
     PROFESSOR:   In other words, here is
not enough include these three.  Right?
Because if i just include these three, I
don't have a key.  So I have to include
the foreign key from either of these
entities so I include ISBN, I include user
ID, and then the rest, the date of loan,
date of return and fine.  So the key for
the loan relation will be ISBN number and
user I-D.  And we're have user ID as the
key and ISBN as the key so they become the
foreign key into the loan relation.
     Now, nobody has any problem with
that?  Right?  This seems natural.
     STUDENT:   Don't you need to add date
of loan to the primary key of the loan
table?
     PROFESSOR:   Here, date of loan.
     STUDENT:   No, but, if the same user
bore rose the same book on different
occasions, that's not uniquely determined
by our two primary keys.
     PROFESSOR:   But we assume that the
same user will have returned that book and
reborrowed.
     STUDENT:   Okay.
     PROFESSOR:   But that's a good point.
That could happen if you allow that to do
that.
     Okay.  So this seems to be a natural
design, okay?  But now if I tell you, I
don't like to have three relations.  I
like simplicity.  I like only have two or
even one relation.  Can you do it?  So let
me rephrase the question.  So you start
with the ER diagram.  Okay.  So it seems
natural you make each entity a separate
relation, the relationship into several
relation, that's fine.  Okay?  In fact,
this is the first approach we can talk
about.  But now if I am not happy, user
not happy, you want to reduce that, can
we?
     STUDENT:   Well, yeah.  You could
either add into the user table ISBN as
like a foreign key but also make it like
part of a key in user.  Or you could say
like how many books they're allowed to
have and book one, book two, book three.
     PROFESSOR:   Yeah?
     STUDENT:   Go ahead.
     PROFESSOR:   Okay.  Now, the key
this.  I want to absorb information into
one table, the question is who is who?
Who assumes which one?
     STUDENT:   If it was a library
information system and the library keeps
books but users are allowed to borrow
them, I would try to interface the user
information into the book relation, so I'd
have information on books, have ISBN and
title --
     PROFESSOR:   So you are put this part
in here?
     STUDENT:   Right.  And then have loan
information like date of loan, date of
return and if there fines on it, then the
user ID.
     PROFESSOR:   And in fact -- have you
a point to make?
     STUDENT:   Yeah.  I would look at it
a different way.  I'd separate the users,
which are part of the outside world and
loans and books are part of the library
system.
     PROFESSOR:   But user tells you he
doesn't like to have three relations, just
one table.
     STUDENT:   Down to one table?
     PROFESSOR:   Yeah.  He wans
simplicity.  Yeah?
     STUDENT:   What does the user care?
Because --
     PROFESSOR:   I'm sorry.  The user I
don't mean end user, I don't mean patron,
I mean the designer, designer/user.  I'm
talking -- I'm not talk about end user.
End user does count, but have you to
realize that end users are not as smart.
They are not like us.  We think we're
smart.  They would like to see the world
as a great big table.
     STUDENT:   Just give them a view.
You know it's better this way.
     PROFESSOR:   Yeah.  I'm just trying
to force the argument.  If I want to
absorb information, but you are correct.
The reader can, there are many books, many
to one, right?  So in other words, for
every book I have just one user.  So it's
more natural I incorporate that in here.
Then I have just one table.  Okay.  In
other words, the whole point is if you see
many to one relationship, you can try to
absorb information through the many side.
If you really rant to do.  Of course,
to -- if you really want to do that.
     Or To be separate may be preferable
but if you have to do it you can.  You see
the point?  In other words sometimes we do
like to simplify the design.  The user or
the customer like to see a simple way of
looking at data.  Of course we can provide
views, but why do we have to have one
table?  And theoretically we can do it
because we have many to one relationship.
     Same goes with one to one.  One to
one of course is even better.  It doesn't
matter you can absorb it either.  Of
course, this is like extreme case where
one user can only loan one book, okay?
Just one book and no more.  Then you can
see that, okay, I can put user information
into the book or conversely, put the book
information to the user table, either way
it will work.
     STUDENT:   If you do that, how does
it stop you, like you say you put users in
the books and it's like a one to one, how
is the database going stop you from
letting multiple --
     PROFESSOR:   Yeah, I see your point.
     STUDENT:   Multiple books because
there is no way to enforce that.
     PROFESSOR:   There are two ways.  One
is to use the integrated constraints.
Okay.  So you write something integrated
constraints saying no user can borrow more
books and we have powerful database
system, it can read into the constraint
and enforce that.  The second way is what
we are doing now.  In other words, you
just have to write program more carefully
so you don't violate that.
     STUDENT:   It's better to do that
other way.
     PROFESSOR:   Exactly.  If you want to
have a simple design, sometimes, this is
better.  Yeah?
     STUDENT:   You're saying that a user
can't borrow more than one book with that
table?
     PROFESSOR:   No, no.  I'm saying this
is just one to many will work as well.  If
I have one to many situation, one user can
borrow many books, I will use books as my
primary table, right?  Because there are
more books but each book can be loaned to
only user, so it's more logical to talk
about books.  But if I have a one to one,
then it doesn't matter, I can talk about
book relation, or I can talk about user
relation.  Okay.
     What we cannot is that if you have
many to many relation, then it will be
highly unlikely, or very difficult to
reduce it to one table.  Okay?  So, let's
summarize this.  In other words, when you
look at ER diagram, you look at
relationship, you obviously will have
three cases.  One to one, one to many, and
many to many.
     If it is one to one or one to many,
you can always absorb a table on to the
many side.  Or one to one either side.
But if it is many to many, can't do that.
then you have to do seems intuitive,
namely come up with three tables.
     So this in fact is the basis of
design using ER day gram to the entity
relationship model.  Once we realize that,
and everything else will fall into place
quite naturally.  Once you have ER day
gram, analyze the relationship it has
conceptually then you can design it into
one or many relations.
     Turn off the lights.  Okay.  It's
really dark.  Okay.  Now, the rest you can
check in the notes.  Basically, it's more
detailed explanation of what I just
described to you.  Of course, there are
also other subjects that need to be
discussed.  Like what happened to weak
entities.  Stuff like that.
     So basically, what you go through is
that you take the ER diagram, and normally
for every entity you make it into
relation.  Unless they are weak entities,
or you have one to one or one to many
relations.  In which cases, you can
eliminate some relations by putting the
data into either the parent relationship
or into the many side of the relationship.
     So, I won't go into the details, I
will ask you to read, this is just a few
pages and so they are all together six
steps which analyze the different type of
relationships and come up with the design.
But just to give you a summary, this is
what we talk about.  Starting from the
semantic model, ER diagram, every entity
type we can make it into relation.  If the
relation type is one to one, or one to
many, you can absorb it.
     And if it is many to many, you cannot
absorb it, you have to make it into
separate relations.  But of course, you
can always play it safe.  Turn on the
lights now.  In other words, if you have
this kind of situation, and you forget the
rules, you don't know what side to absorb?
What do you do?  You do it wasteful way,
every entity type you make a relation,
every relationship you also make a
relation.  As long as you remember to
include foreign keys, everything, it will
work.  It may be more wasteful I may not
be the best design, but it will work.  So
that's the bottom line.  But they are
tradeoff that we can either use more
relations or less relations and depending
upon what a user like, we can satisfy
users's requirements.  So these three
pages please read carefully because it's
not that trivial.  I didn't tell you in
great detail about the weak entity type.
But that's it.  So, on Thursday, you still
can hand in your project and also goes to
other database models.
24
25
26

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="GENERATOR" CONTENT="Notepad/Robert Hofmann">
<BASE TARGET="1502main">

<TITLE>Unit1c : Creating the Shifter Sub-Block</TITLE>

</HEAD>

<BODY BACKGROUND="../Unitbkg.jpg">
<H2><CENTER>Unit 1c</CENTER></H2>
<H2><CENTER>Creating the Shifter Sub-Block</CENTER></H2>

<CENTER><H3>The Shifter</H3></CENTER>
<P>
  The <I>Shifter</I> block, as the name implies, is responsible
  for taking the input operand, <I>A</I>, and shifting it either
  left or right by a number of bits specified by the SHAMT_HIGH and 
  SHAMT inputs.
  SHAMT_HIGH and SHAMT is interpreted as a six-bit unsigned integer, thus 
  allowing us to shift the input by zero to sixty-three bits.
</P>
<P>
  The direction is specified by the higher order control bit:
  <LI>ALUOp(1) = 0 means shift left</LI>
  <LI>ALUOp(1) = 1 means shift right</LI>
</P>
<P>
  In addition to direction, we must also specify whether the
  shift is arithmetic or logical, but this is only meaningful
  for right shifts.  A logical shift fills the bits vacated
  at the end with zeros.  An arithmetic shift fills the bits
  vacated at the left end on a right shift with copies of the
  sign bit, since for signed twos complement integers all bits
  to the left of the represented number are considered to 
  be the same as the sign.  Arithmetic right shifts allow
  a right shift on a signed integer to be interpreted as a
  division by 2**(SHAMT_HIGH concatenated with SHAMT).  
  There is no special arithmetic left
  shift (corresponding to a multiply by 2**(SHAMT_HIGH concatenated with SHAMT)) because all 
  of the bits to the right of the binary point are considered
  to be zeros.
</P>
<P>
  The type of shift is specified by the ALUOp(0) control bit:
  <LI>ALUOp(0) = 0 means a logical shift</LI>
  <LI>ALUOp(0) = 1 means an arithmetic shift</LI>
  ALUOp(0) should never be equal to one at the same time as
  ALUOp(1) is equal to zero.  This will be ensured by the control
  unit.
</P>

<CENTER><H3>Implementing the Shifter with a Flowchart</H3></CENTER>

<P>
  We will be implementing the <I>Shifter</I> block with a
  Flowchart view.  A flowchart view creates a VHDL process
  block containing sequential statements to describe the 
  behavior.  Sequential VHDL statements can only be found
  within special constructs called processes.  Within a 
  process, these statements are executed, as the name implies,
  sequentially.  They consist of such statements as 
  <I>if..then..else</I>, <I>case</I>, and <I>wait</I>.
</P>

<UL>
<LI>
  <P>
    To begin, first we need to create a <I>Flowchart View</I> 
    for the <I>Shifter</I> sub-block in the <I>ALU</I> block 
    diagram.  Do this by right-clicking over this sub-block
    in the <I>ALU</I> design window and selecting <I>Open/New
    View</I>.  In the window which appears, select <I>Flowchart
    View</I> from the list box.  An empty flowchart similar to 
    Figure 1 will appear.
  </P>

  <P>
    <CENTER>
      <IMG SRC="./FlowChart1.jpg">
      <H4>Figure 1</H4>
    </CENTER>
  </P>
  
  <P>
    You will notice that there are no ports or signals 
    visible on the flowchart.  This is because this is a 
    purely behavioral description of the block, with no 
    structural elements as in the block diagram view.  All 
    of the signals which are connected to the sub-block 
    in the <I>ALU</I> block diagram will be visible within 
    the process.  You will have to remember them though.
  </P>

  <P>
    At the top of the design area, there are four boldface  
    headings:
    <UL>
    <LI>
      <P>
        <I>Architecture Declarations</I> is for adding 
        additional internal signals which are visible 
        in the entire architecture.
      </P>
    </LI>
    <LI>
      <P>
        <I>Concurrent Statements</I> is for adding concurrent 
        VHDL statements to the architecture outside of the 
        process.  The logic of these statements will be in 
        parallel with the process logic.
      </P>
    </LI>
    <LI>
      <P>
        <I>Sensitivity List</I> is for declaring which signals,
        if any, the process will be sensitive to.  Sensitivity
        to a signal means that the process is "activated" by a 
        change in that signal.
      </P>
    </LI>
    <LI>
      <P>
        <I>Process Declarations</I> is for declaring signals or
        variables which exist only within the scope of the
        process.  Thus, these signals can only be referenced from
        within the process.
      </P>
    </LI>
  </UL>

  <P>
    Since a process is sequential, it lends itself to a flowchart
    representation.  The first step in creating the flowchart is
    to place a <I>Start</I> block on the design area by activating
    the <I>Add Start Point</I> tool, <IMG SRC="./FC_StartButton.jpg">.
  </P>
  
  <P>
    <CENTER>
      <IMG SRC="./FlowChart2.jpg">
      <H4>Figure 2</H4>
    </CENTER>
  </P>
</LI>

<LI>
  <P>
    The first thing that we want to do is to decide whether we
    are shifting left or shifting right.  To do this, we will 
    place a decision box into the design just below the start
    block using the <I>Add Decision Box</I> tool, 
    <IMG SRC="./FC_DecisionButton.jpg">.  This will add a yellow
    diamond to the flowchart with reddish triangles at two of
    its points labelled <I>T</I> for TRUE and <I>F</I> for FALSE.
    The flowchart will now look like Figure 3a.
  </P>

  <P>
    We have added a decision box, but we haven't yet told it
    which decision to make.  To do this, we need to enter an
    expression which evaluates to TRUE or FALSE inside the 
    decision box in place of the text labelled <I>condition</I>.
    Since ALUOp(1) specifies the Left/Right shifting, we will 
    enter <I>ALUOp(1) = '0'</I> as the condition.  Now if
    we are shifting left, and ALUOp(1) = '0', we will follow the 
    TRUE branch, otherwise we will be following the FALSE branch
    which will perform a right shift.
  </P>
  <P>
    To even things out visually, we will also move the TRUE branch
    source, the small reddish triangle labelled <I>T</I>, to
    the left corner of the yellow diamond.  Finally, rename the
    decision box by highlighting the default name <I>d0</I> and
    entering <I>LeftorRight</I> Your flowchart should look like 
    Figure 3b now.
  </P>

  <CENTER>
  <P>
    <TABLE>
      <TR>
        <TD WIDTH="50%">
          <CENTER><IMG SRC="./FlowChart3a.jpg"></CENTER>
        </TD>
        <TD WIDTH="50%">
          <CENTER><IMG SRC="./FlowChart3b.jpg"></CENTER>
        </TD>
      </TR>
      <TR>
        <TD>
          <CENTER><H4>Figure 3a</H4></CENTER>
        </TD>
        <TD>
          <CENTER><H4>Figure 3b</H4></CENTER>
        </TD>
      </TR>
    </TABLE>
  </P>
  </CENTER>
</LI>

<LI>
  <P>
    We will now go on to filling in the left-hand branch of
    this decision, implementing the left-shift.  We are going 
    to implement the shift in stages.  We begin by looking at
    bit 0 of the SHAMT.  If it is a one, then we will be shifting
    left by one bit into an intermediate result <I>LeftOne</I>.
    Otherwise, we will simply pass-thru the unshifted value of
    the input to the intermediate result.
  </P>
  <P>
    Since <I>LeftOne</I> does not yet exist in this architecture,
    we must add a declaration for it.  Due to some details in the
    way that VHDL is simulated and synthesized, we will not be
    able to declare LeftOne as a signal for the architecture or
    even a signal in the process and expect to get the correct
    results.  This is because when an assignment is made to a
    signal within a process, subsequent references to that signal
    later in the same process will still reflect the value of
    the signal when the process began.  It is not until the next
    iteration through the process that the change will be seen.
    In order to create an intermediate value whose value can 
    change within a single trip through the process block, we will
    declare <I>LeftOne</I> as a <B>variable</B> with the process.
  </P>
  <P>
    We add a process declaration by right-clicking over an empty
    portion of the flowchart and selecting <I>Flow Chart
    Properties</I> from the pop-up menu.  Select the <I>Process
    Declarations</I> tab and type the declaration in the white
    text area:
    <PRE>
        variable LeftOne : std_logic_vector(63 downto 0);
    </PRE>
    As you can see, the variable may take any valid VHDL type
    and the declaration syntax is similar to that of architecture
    signals in the <I>Logical</I> sub-block.  The properties window
    should look like Figure 4.  Once it does, click OK.
  </P> 
  <P>
    <CENTER>
      <IMG SRC="./FlowChart4.jpg">
      <H4>Figure 4</H4>
    </CENTER>
  </P>
  <P>
    Now that we have declared the variable to store the
    intermediate result, we need to add the logic to
    assign the proper value.  Add a second decision box to the
    left of and just below the <I>LeftorRight</I> box and connect
    a flow to it from the TRUE branch of the <I>LeftorRight</I>
    box.  Rename this new box <I>LeftOneorNone</I> and set its 
    condition to <I>SHAMT(0) = '1'</I>.  On a TRUE, we will
    shift <I>A</I> left by one and assign the result to 
    <I>LeftOne</I>, otherwise we will simple assign <I>A</I>.
    Once again, shift the TRUE branch so it is on the left 
    corner of the diamond.
  </P>
  <P>
    In order to make the assignments, we will be adding 
    <I>Action Boxes</I> to the flowchart.  An <I>Action Box</I>
    allows you to enter one or more lines of sequential VHDL
    which will be placed into the process at the appropriate
    point.  Select the <I>Add Action Box</I> tool, 
    <IMG SRC="./FC_ActionButton.jpg">, and place an <I>Action
    Box</I> just below and to the left of the <I>LeftOneorNone</I> decision
    box.  Add a flow from the TRUE branch of that <I>Decision Box</I>
    to the new action box.  Rename the <I>Action Box</I> as
    <I>LeftOneBox</I>.
  </P>
  <P>
    To give the <I>Action Box</I> behavior, either highlight the
    text <I>actions;</I> inside it or right-click on it and
    select <I>Object Properties</I>.  Here you will enter the
    sequential VHDL that will describe the behavior.  In this case,
    since we want to assign bits (62 DOWNTO 0) of <I>A</I> to 
    LeftOne(63 DOWNTO 0) and a zero to LeftOne(0), accomplishing
    a shift left by one, we will use the following line of code:
  <PRE>
    LeftOne(63 DOWNTO 0) := A(62 DOWNTO 0) & '0';
  </PRE>
  <P>
    * (The ampersand concatenates two bit-strings together.)
  </P>
  <P>
    ** (Assignment to a variable is done with ':=' instead of '<='.)
  </P>
  <P>
    When you have entered this text, click OK if you were in
    the <I>Object Properties</I> window or click on an empty
    part of the flowchart if you were editing in the box.
    You may resize the box so that it fits the text.  Make sure
    you don't leave out the semi-colon at the end of the line.
    Your flowchart should now look something like Figure 5.
  </P>
  <P>
    <CENTER>
      <IMG SRC="./FlowChart5.jpg">
      <H4>Figure 5</H4>
    </CENTER>
  </P>
</LI>

<LI>
  <P>
    Now add a second <I>Action Box</I> to the right of the first
    one and a flow connecting it to the FALSE branch of the 
    <I>LeftOneorNone</I> box.  Use the flow buttom (<img src="FC_FlowButton.jpg">) to make
    this connection.  Name this action box <I>LNoneOne</I>
    and add the following action:
  <PRE>
    LeftOne(63 DOWNTO 0) := A(63 DOWNTO 0);
  </PRE>
  </P>
</LI>

<LI>
  <P>
    Regardless of whether we shifted by one or not, we now
    want to check whether to shift further by two.  Place
    a new <I>Decision Box</I> below the two <I>Action Boxes</I>
    and add flows from both action boxes to its source.
  </P>
  <P>
    Name the new <I>Decision Box</I> as <I>LeftTwoorNone</I> and
    set its condition to <I>SHAMT(1) = '1'</I>.  Now declare a 
    new process variable called <I>LeftTwo</I> which is of type
    std_logic_vector(63 DOWNTO 0).  Create a similar structure 
    to the one just made with two <I>Action Boxes</I> with the
    actions:
  </P>
  <P>
    <B>FALSE -></B> LeftTwo(63 DOWNTO 0) := LeftOne(63 DOWNTO 0);
  </P>
  <P>
    <B>TRUE -></B> LeftTwo(63 DOWNTO 0) := LeftOne(61 DOWNTO 0) & "00";
  </P>
  <P>
    Your flowchart should now look like Figure 6.
  </P>
  <P>
    <CENTER>
      <IMG SRC="./FlowChart6.jpg">
      <H4>Figure 6</H4>
    </CENTER>
  </P>
</LI>

<LI>
  <P>
    In a similar manner, add the flow for the shift by four, 
    shift by eight, shift by sixteen, and shift by thirty-two.  
    You will need three
    more variable declarations <I>LeftFour</I>,  <I>LeftEight</I>, and
    <I>LeftSixteen</I>.
    At the last level, assign the result to <I>ShifterR</I>.
    Finally, connect the flows from the last two <I>Action Boxes</I>
    to an <I>End</I> box.  The extended flow can be seen in Figure 7.
  </P>
  <P>
    <CENTER>
      <IMG SRC="./FlowChart7.jpg">
      <H4>Figure 7</H4>
    </CENTER>
  </P>
</LI>

<LI>
  <P>
    Filling in the right shifting half of the flowchart will
    be very similar to filling in the left half.  The only
    difference will be that we need to account for a possible
    arithmatic shift.  This will require an extra <I>Decision
    Box</I> at the top of the right branch to determine what
    values to shift into the vacated bits.  We will define a
    variable called <I>Fill</I> which will be a 
    std_logic_vector(32 DOWNTO 0) because we will need to be
    able to fill up to 32 vacated bits.  This variable
    will be initialied from the sign bit with a loop.
  </P>
</LI>

<LI>
  <P>
    First, declare a 32 bit variable called <I>Fill</I> and
    64 bit variables called <I>RightOne</I>, <I>RightTwo</I>,
    <I>RightFour</I>, <I>RightEight</I>, and <I>RightSixteen</I> 
    in the process.
  </P>
</LI>

<LI>
  <P>
    Now select the <I>Add Start Loop</I> tool and place a green
    <I>Loop Start</I> box just below and to the right of the 
    <I>LeftorRight</I> box.  This loop will have three flow
    contact points (reddish triangles).  The one at the top is
    where we enter the loop.  Connect a flow to this point from
    the FALSE branch of the <I>LeftorRight</I> box.  The point
    on the left side of the oval is the return from the end of
    the loop and the point on the bottom is the entrance into
    the loop body.  Rename the loop <I>FillLoop</I>.
  </P>
  <P>
    For the loop condition, we want to have a <I>for loop</I> 
    which will loop 32 times with indices 0 to 31.  To accomplish 
    this, open the <I>Object Properties</I> window for the  
    <I>Loop Start</I> box.  We do not want to loop infinitely,
    so under the <I>Loop Control</I> section, select the 
    <I>Specify</I> button.  In the text box, type:
    <I>for i in 0 to 31</I>, then press <I>Apply</I> and <I>OK</I>.
    The top right of the flowchart should now look like
    Figure 8.
  </P>
  <P>
    <CENTER>
      <IMG SRC="./FlowChart8.jpg">
      <H4>Figure 8</H4>
    </CENTER>
  </P>
  <P>
    The action of this loop will be to assign <I>Fill(i)</I>
    to the sign bit, <I>A(63)</I>, if <I>ALUOp(0)</I> = '1' or
    to zero if <I>ALUOp(0)</I> = '0'.  This is equivalent to
    <I>A(63)</I> <B>AND</B> <I>ALUOp(0)</I>.  Add an action box
    box named <I>FillBox</I> below the <I>Loop Start</I> and add
    a flow from the latter to the former.  Define the action
    as:
  </P>
  <PRE>
        Fill(i) := ALUOp(0) AND A(63);
  </PRE>
  <P>
    Add an <I>End Loop</I> box below the <I>Action</I> box.  
    Create flow from the <I>Action</I> box to the top of the
    <I>End Loop</I> and from the left side of the <I>End Loop</I>
    back to the left side of the <I>Start Loop</I>.
  </P>
  <P>
    Your flowchart should now look like Figure 9.
  </P>
  <P>
    <CENTER>
      <IMG SRC="./FlowChart9.jpg">
      <H4>Figure 9</H4>
    </CENTER>
  </P>
</LI>

<LI>
  <P>
    Now, below the loop, repeat the structure from the left
    side of the flowchart.  The only difference will be in the
    actions you will be shifting right and, instead of a 
    constant string of zeros, you will be filling vacated space
    with a slice of the <I>Fill</I> variable.  For example, for
    an eight bit shift you would do: 
  </P>
  <PRE>
    RightEight(63 downto 0) := Fill(7 downto 0) & RightFour(63 downto 8);
  </PRE>
  <P>
    Fill in the remainder of the right side yourself.  When you are
    done it should look like Figure 10.
  </P>
  <P>
    <CENTER>
      <IMG SRC="./FlowChart10.jpg">
      <H4>Figure 10</H4>
    </CENTER>
  </P>
</LI>

<li>
<p>
Make sure you add the following process declarations:
<pre>
variable LeftOne : std_logic_vector(63 downto 0);
variable LeftTwo : std_logic_vector(63 downto 0);
variable LeftFour : std_logic_vector(63 downto 0);
variable LeftEight : std_logic_vector(63 downto 0);
variable LeftSixteen : std_logic_vector(63 downto 0);
variable RightOne : std_logic_vector(63 downto 0);
variable RightTwo : std_logic_vector(63 downto 0);
variable RightFour : std_logic_vector(63 downto 0);
variable RightEight : std_logic_vector(63 downto 0);
variable RightSixteen : std_logic_vector(63 downto 0);
variable Fill : std_logic_vector(31 downto 0);
</pre>
</p>
</li>

<li>
<p>
Also, <b>MAKE SURE YOU ASSIGN SIGNALS (i.e. ShifterR) USING THE <= OPERATOR AND
VARIABLES (i.e. LeftFour) WITH THE := OPERATOR!</b>
</p>
</li>

<LI>
  <P>
    When you have completed the flowchart for the <I>Shifter</I> sub-block as 
    outlined above, you are ready to <A HREF="./ALU_ShiftSim.html">
    Simulate the Shifter sub-block</A>.
  </P>
</LI>

</UL>
</HTML>
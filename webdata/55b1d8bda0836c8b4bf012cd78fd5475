<title>MINIPROJECT</title>
<br>
<h1>MINIPROJECT</h1>
<center><a href="http://blue.cs.ksi.edu/dl/cs156x/p1.rm">Click here for an audio lecture that can be played using RealPlayer</a></center>
<center><xs><a href="http://www.cs.pitt.edu/~chang/156/lecture/p1">Click here for audio-text lecture and feed it to the speech agent</a></xs></center>
<br>
The miniproject is 10 points plus 3 extra bonus points for early submission,
and 3 extra bonus points for completion of optional part.
<br><br>
Select one project from the projects described below.  You may not design your own project.
You may not select more than one project.
<br><br><b>If you are a graduate student, you are also required
to turn in a <a href="../231/guide.html">project report</a> and give a five-minute project presentation and a live demo.  If you
are an undergraduate student, you are required to turn in a
single-page readme file and give a live demo, but not required to turn in
a project report.</b>
<br><br>
<h2>Project 1: SQL Compiler</h2>
Implement the SQL compiler discussed in
part (ii) of Exercise 3.
You may use any compilable programming language in the implementation,
except PERL, PYTHON and other interpretive languages.
Although PERL program can be compiled it will still be disallowed.
When you are ready to turn in the project, bring your diskette containing source, executable and test data, so that
you can give the instructor a live demo.
The miniproject is to implement the SQL Compiler to translate simplified SQL
queries into relational algebraic queries.  The simplified SQL queries are of the following form:
<ul>
<a name="Q0"><b>Simplified SQL Query:</b></a><br>
 SELECT attribute-list<br>
 FROM relation-list  (could be different relations)<br>
 WHERE conditions  (could involve R1.A1 = R2.A2)<br>
</ul>

<b>Optional Part P2:</b>
3 bonus points if you also implement the relational operators
Project, Select and Join,
so that your program is a complete system to translate
and execute simplified SQL queries.  (If you can only implement project and 
select, you will still get <i>some</i> bonus points!)
<br><br>
<b>Files on Diskette:</b>
There should be the following files on the diskette you turn in:

<ul>
README (a short user's manual explaining how your program works)<br>
P1.exe (program to translate SQL into relational algebra)<br>
P1.source (source for P1.exe)<br>
<a href="#DBD">DBD</a> (input database schemas in ascii file)<br>
<a href="#Q1">Q1</a> (input query in ascii file)<br>
<a href="#Q2">Q2</a> (input query in ascii file)<br>
<a href="#T1">T1</a> (output relational algebraic query in ascii file)<br>
T2 (output relational algebraic query in ascii file)<br>
</ul>
(Obviously, you can have Q3, Q4, ..., etc.   You should prepare a mixture of
queries, starting from simple ones, then to more complex ones, plus queries
containing syntactic errors or semantic errors.)<br>
<br>
For the optional part P2, there should be the following files:
<ul>
README (a short user's manual explaining how your progrm works)<br>
P2.exe (program to execute the translated query)<br>
P2.source (source for P2.exe)<br>
<a href="#INDATA">INDATA</a> (input data for populating the database)<br>
<a href="#OUTDATA">OUTDATA</a> (results after executing a relational algebraic query in T1, T2, etc.)<br>
</ul>

The database definition (DBD) file may look like this:
<ul>
<a name="DBD"><b>DBD:</b></a><br>
3 (# of relations)<br>
S (name of relation)<br>
3 (# of attributes)<br>
S# (name of first attribute)<br>
2 (length of first attribute)<br>
SNAME (name of second attribute)<br>
10 (length of second attribute)<br>
CITY (name of third attribute)<br>
8 (length of third attribute)<br>
P (name of second relation)<br>
2 (# of attributes)<br>
P# (name of first attributed)<br>
2 (length of first attribute)<br>
PNAME (name of second attribute)<br>
10 (length of second attribute)<br>
SP (name of third relation)<br>
2 (# of attributes)<br>
S# (name of first attribute)<br>
2 (length of first attribute)<br>
P# (name of second attribute)<br>
2 (length of second attribute)<br>
</ul>
The input data file (INDATA) may look like this:
<ul>
<a name="INDATA"><b>INDATA:</b></a><br>
S (name of relation)<br>
2 (# of tuples)<br>
S1     Chang   Paris<br>
S2     Smith  London<br>
P (name of relation)<br>
2 (# of tuples)<br>
P1     Nut<br>
P3     Screw<br>
SP (name of relation)<br>
3 (# of tuples)<br>
S1P1<br>
S1P3<br>
S2P3<br>
</ul>
<br>
Translated queries can either be stored in files <a href="#T1">T1</a>, T2, etc. or
displayed on the screen.  Final output should be displayed on the screen.
<br><br>
Test your program on the following
examples:
<ul>
<a name="Q1"><b>Q1:</b></a><br>
SELECT S#, SNAME, CITY<br>
FROM S<br>
WHERE S# = 'S1'<br>
<br><br>
<a name="Q2"><b>Q2:</b></a><br>
SELECT S#,  CITY<br>
FROM S, SP<br>
WHERE P# = 'P2' AND S.S# = SP.S#<br>
<br><br>
</ul>
The translated relational algebraic query T1 may look like:<br>
<ul>
 <a name="T1"><b>T1:</b></a><br>
 t1 = project S [S#]<br>
 display t1<br>
</ul>
It is important to understand that the relational algebra
is a procedural language.  Therefore you should generate
one command line for each relational algebraic operator.
If you just use simple pattern matching then you will not
be able to distinguish restrict and join operators.
Your program will not work correctly and you may lose 3 or more points!
<p>
The results to execute a query may look like:
<ul><pre>
 <a name="OUTDATA"><b>OUTDATA:</b></a><br>
 Result:
            S#  SNAME   CITY
            --  -----   -----
            S1  Chang   Paris
</pre></ul>
<h2>Grading</h2>
6 for successfully doing P1 to translate queries (correctness)<br>
1 capability to handle different DBD (0.5) and join queries (0.5) (generality)<br>
1 capability to detect syntactic errors (0.5) and semantic errors (0.5) in input queries (error handling)<br>
2 quality of programming (0.5), comments in source codes (0.5), display format (0.5), user's manual (0.5) (quality)<br>
3 bonus points for doing P2 to execute queries<br>
3 bonus points for early submission<br>

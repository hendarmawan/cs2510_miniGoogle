<title>OBJECT-ORIENTED DATABASE (OODB)</title>

<h1>OBJECT-ORIENTED DATABASE (OODB)</h1>
<center><xs><a href="http://www.cs.pitt.edu/~chang/156/lecture/19">Click here for audio-text lecture and feed it to the speech agent</a></xs></center>

<b>
<li> Object-Oriented Language Features:<br>
      abstract data types<br>
      inheritance<br>
      object identity<br>
<br><br>
<li> Object-Oriented Database Features:<br>
      persistence<br>
      support of transactions<br>
      simple querying of bulk data<br>
      concurrent access<br>
      resilience<br>
      security<br>
<hr>
<h1>WHY OBJECT-ORIENTED DATABASE?</h1>
<li> Industry Trends:<br>
     Integration and Sharing
<br><br>
<li> Seamless integration of operating systems,
     databases, languages, spreadsheets,
     word processors, AI expert system shells.
<br><br>
<li> Sharing of data, information, software
     components, products, computing
     environments.
<br><br>
<li> Referential sharing:<br>
     Multiple applications, products, or
     objects share common sub-objects.
<br><br>
     (Hypermedia links are then used to
      navigate from one object to another)
<br><br>
     Object-oriented databases allows
     referential sharing through the support
     of object identity and inheritance.
<hr>
<h1>Fundamentals of Object-Oriented Approach</h1>

The object-oriented paradigm is illustrated below:
<br><IMG SRC="images/fig191.gif"><br>
<h2>Objects and Identity</h2>
The following figure shows object with state and behavior. The state
is represented by the values of the object's attributes, and
the behavior is defined by the methods acting on the state of the object.
There is a unique object identifier OID to identify the object.
<br><IMG SRC="images/fig192.gif"><br>

<h2>Complex Objects</h2>
Complex objects are built by applying constructors to simpler
objects including: sets, lists and tuples.
An example is illustrated below:
<br><IMG SRC="images/fig193.gif"><br>

<h2>Encapsulation</h2>
Encapsulation is derived from the notion of Abstract Data Type (ADT).
It is motivated by the need to make a clear distinction between the
specification and the implementation of an operation.
It reinforces modularity and provides a form of logical data independence.
<br><IMG SRC="images/fig194.gif"><br>

<h2>Class</h2>
A class object is an object which acts as a template.
<p>
It specifies:<br>
A structure that is the set of attributes of the instances<br>
A set of operations<br>
A set of methods which implement the operations
<p>
Instantiation means generating objects,
Ex. 'new' operation in C++
<p>
Persistence of objects: Two approaches<br>
An implicit characteristic of all objects<br>
An orthogonal characteristic - insert the object into a
persistent collection of objects<br>

<h2>Inheritance</h2>
A mechanism of reusability, the most powerful concept of OO programming
<br><IMG SRC="images/fig195.gif"><br>

<h2>Association</h2>
Association is a link between entities in an application
<p>
In OODB, associations are represented by means of references between objects<br>
a representation of a binary association<br>
a representation of a ternary association<br>
reverse reference<br>
<br><IMG SRC="images/fig197.gif"><br>
<br><IMG SRC="images/fig198.gif"><br>

<hr>
<h1>ADVANTAGES OF OODB</h1>
<li> An integrated repository of information
     that is shared by multiple users, multiple
     products, multiple applications on
     multiple platforms.
<br><br>
<li> It also solves the following problems:
<br><br>
1. The semantic gap: The real world and the
   Conceptual model is very similar.
<br><br>
2. Impedance mismatch: Programming languages
   and database systems must be interfaced
   to solve application problems.  But the
   language style, data structures, of a
   programming language (such as C) and the
   DBMS (such as Oracle) are different. The
   OODB supports general purpose programming
   in the OODB framework.
<br><br>
3. New application requirements: Especially in
   OA, CAD, CAM, CASE, object-orientation is
   the most natural and most convenient.

<hr>
<h1>COMPLEX OBJECT DATA MODELS</h1>
Complex object data model is non-1NF
data model.  It allows the following
extensions:
<br><br>
1. Sets of atomic values<br>
2. Tuple-valued attributes<br>
3. Sets of tuples (nested relations)<br>
4. General set and tuple constructors<br>
5. Object identity
<br><br>
Formal definition:
<br><br>
1. Every atomic value in A is an object.<br>
2. If a1, ..., an are attribute names in N,
   and O1, ..., On are objects, then
   T = [a1:O1, ..., an:On] is also an
   object, and T.ai retrieves the value Oi.<br>
3. If O1, ..., On are objects, then
   S = {O1, ..., On} is an abject.
<br><br>
Example:
  {[Name:John, Age: 30],<br>
   [Name:Mary, Friends:{Mark, Vicki}]}
<br><br>
<font color=red>
<h3>An object is defined by a triple (OID, type constructor, state)
where OID is the unique object identifier, type constructor is
its type (such as atom, tuple, set, list, array, bag, etc.) and
state is its actual value.</h3>

Example:<br>
(i1, atom, 'John')<br>
(i2, atom, 30)<br>
(i3, atom, 'Mary')<br>
(i4, atom, 'Mark')<br>
(i5, atom 'Vicki')<br>
(i6, tuple, [Name:i1, Age:i3])<br>
(i7, set, {i4, i5})<br>
(i8, tuple, [Name:i3, Friends:i7])<br>
(i9, set, {i6, i8})
</font>
<br><br>
<hr>
<h1>Semantic Data Models</h1>
The following figure shows different types of nodes in GSM.
<br><IMG SRC="images/fig1911.gif"><br>
<br><br><br><br>
The different types of links (relationships) in GSM are shown below.
<br><IMG SRC="images/fig1912.gif"><br>
<br><br><br><br>
A semantic model for the sales office automation example is shown below.
<br><IMG SRC="images/fig1913.gif"><br>
<br><br><br><br>
An entity-relationship model for the sales office automation example is shown below.
<br><IMG SRC="images/fig1914.gif"><br>
<hr>
<h1>OBJECT-ORIENTED DATABASES</h1>

<h3>OODB = Object Orientation + Database Capabilities</h3>

FEATURES TO BE CONSIDERED:
<br><br>
      persistence<br>
      support of transactions<br>
      simple querying of bulk data<br>
      concurrency control<br>
      resilience and recovery<br>
      security<br>
      versioning<br>
      integrity<br>
      performance issues
<br><br>
DATA MODELS TO BE CONSIDERED:
<br><br>
      Complex object model<br>
      Semantic data model
       such as Extended ER (EER) model, OPM model
<br><br>
NOT ALL OODB SUPPORTS SAME OBJECT-ORIENTATION,
SAME DATA MODEL AND SAME SET OF FEATURES
<hr>
<h1>RESEARCH PROTOTYPES</h1>
<br><br>
<li> ORION: Lisp-based system, built at MCC 1987.
     Handles schema evolution and complex
     object locking.
<br><br>
<li> IRIS: Built at HP 1987. Functional data
     model, version control, object-SQL.
<br><br>
<li> Galileo: Built at Univ Pisa 1985. Strong
     typed language, complex objects.
<br><br>
<li> PROBE: CCA 1986.
<br><br>
<li> POSTGRES: Univ. California, Berkeley 1990.
     Extended relational database supporting
     objects.
<hr>
<h1>COMMERCIAL OODB</h1>
<font color=red>
<li> O2: O2 Technology.
     Language O2C to define classes, methods
     and types.  Supports multiple inheritance.
     C++ compatible.
     Supports an extended SQL language O2SQL
     which can refer to complex objects.
<br><br>
<li> G-Base: Graphael 1987. Lisp-based
     system, supports ADT, multiple
     inheritance of classes.
<br><br>
<li>CORBA: Standards for distributed objects.
</font>
<br><br>
<li> GemStone: Servio Logic 1987, Beaverton,
     Oregon.  Earliest OODB supporting
     object identity, inheritance,
     encapsulation.  Language OPAL is
     based upon Smalltalk.
<br><br>
<li> Ontos: Ontologic, 1988, Berlington,
     Mass.  C++ based system, offers C++
     clients library.  Ontos has a predecessor
     called Vbase.  Ontos model supports
     encapsulation, inheritance, ability
     to construct complex objects.
<br><br>
<li> Object Store: Object Design Inc.
     C++ based sustem.  A good feature is that
     it supports the creation of indexes.
<br><br>
<li> Statics: Symbolics 1988. Supports
     entity types, set valued attributes,
     and inheritance of entity types
     and methods.
<hr>
<h1>COMMERCIAL OODB (continued)</h1>
<li> SIM: Semantic Information Manager,
    UNISYS 1987.  Supports semantic data
    model.  Core system of the InfoExec
    Environment of UNISYS. Uses the Semantic
    Data Model of Hammer and McLeod 1981.
    User can define entity types that can
    inherit from one another. Attributes
    of entities are like functions from
    one entity to another.
<br><br>
<li> Relational DB Extensions: Many relational
    systems support OODB extensions.
<br><br>
1. User-defined functions (dBase).
<br><br>
2. User-defined ADTs (POSTGRES)
<br><br>
3. Very-long multimedia fields (BLOB or
   Binary Large Object). (DB2 from IBM,
   SQL from SYBASE, Informix, Interbase)
<hr>
<h1>ALTERNATIVE OODB STRATEGIES</h1>
1. Develop novel database data model
   or data language (SIM)
<br><br>
2. Extend an existing database language
   with object-oriented capabilities.
   (IRIS, O2 and VBASE/ONTOS extended SQL)
<br><br>
3. Extend existing object-oriented
   programming language with database
   capabilities (GemStone OPAL extended
   SmallTalk)
<br><br>
4. Extendable object-oriented DBMS
   library (ONTOS)
<hr>
<h1>OODB QUERY LANGUAGE</h1>
ONTOS (from Ontologic), O2 (from O2 Technology) and IRIS
(from HP) all offer object-oriented
extension of SQL.
<br><br>
IRIS has Object SQL.  Each entity
type specifies one or more properties.
Properties are functions that apply
to the instances of the type.
Entity types have extensions and
can inherit from one another.
<br><br>
Example: The type PERSON can be
created by:
<pre>
Create Type Person (
  Name		char(20),
  Age		integer
  Address	address)
</pre>
where address is another type.
In IRIS, Name, Age and Address are
called properties (functions) and
apply to instances of type Person.
<hr>
<h1>OODB QUERY LANGUAGE (continued)</h1>
Object SQL Query: retrieve the name and
state of all people who are older than 21:
<pre>
Select Name(p), State(Address(p)
for each Person p
where Age(p) > 21
</pre>

(Here we assume address has another property
called "state")
<br><br>
The user can compose the function application:
<br><br>
P5(P4(...P1(P))...)
<br><br>
in the select statement.  
<br><br>
EXAMPLE:<br>
  Employee is a subtype of Person<br>
  SalesPerson is a subtype of Employee<br>
  Addresses have street names<br>
  Salespeople have sales managers<br>
  sales managers have secretaries<br>
  secretaries are employees<br>
<br><IMG SRC="images/fig1915.gif"><br>
<br><br>
Retrieve the street name of the address
of the secretary of the manager of each
salesperson whose salary is more than 50,000:
<pre>
Select
 StreetName(Address(Secretary(Manager(0))))
 for each SalesPerson p
 where Salary(p) > $50,000
</pre>
<hr>
<h1>WHY EXTENDING SQL?</h1>
<li> SQL is the most popular relational
     query language
<br><br>
<li> SQL is also the only relational language
     that has a standard.
<br><br>
<li> SQL is being promoted by many
     companies as the interface language
     for database engines and database
     servers.  New applications developed
     in SQL extensions can easily call
     these servers for remote access.

<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="Unit5_files/filelist.xml">
<link rel=Edit-Time-Data href="Unit5_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>UNIT 5: Modelling the memory</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Optical Computing Labratory</o:Author>
  <o:LastAuthor>ajnoyola</o:LastAuthor>
  <o:Revision>11</o:Revision>
  <o:TotalTime>16</o:TotalTime>
  <o:Created>2006-10-30T17:19:00Z</o:Created>
  <o:LastSaved>2006-11-07T15:37:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1350</o:Words>
  <o:Characters>7697</o:Characters>
  <o:Company>University of Pittsburgh</o:Company>
  <o:Lines>64</o:Lines>
  <o:Paragraphs>18</o:Paragraphs>
  <o:CharactersWithSpaces>9029</o:CharactersWithSpaces>
  <o:Version>11.6408</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>BestFit</w:Zoom>
  <w:GrammarState>Clean</w:GrammarState>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:387732650;
	mso-list-type:hybrid;
	mso-list-template-ids:1804271496 -768694896 -271144090 -280572116 -2063850344 1446138670 -1507420552 561145196 1945957946 -1330495110;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l0:level2
	{mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level3
	{mso-level-tab-stop:1.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level4
	{mso-level-tab-stop:2.0in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level5
	{mso-level-tab-stop:2.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level6
	{mso-level-tab-stop:3.0in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level7
	{mso-level-tab-stop:3.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level8
	{mso-level-tab-stop:4.0in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level9
	{mso-level-tab-stop:4.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="3074"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body bgcolor=white background="../Unit4/Unitbkg.jpg" lang=EN-US link=blue
vlink=blue style='tab-interval:.5in'>

<div class=Section1>

<h2 align=center style='text-align:center'>UNIT 5: A memory model for the
multicycle CPU</h2>

<p><br>
At this point you should have finished your multi-cycle CPU (including state
controller) design. You have also simulated the design for correct execution of
each instruction (one-at-a-time). When we proceed to synthesis, your CPU will
fetch instructions and data from<span class=GramE>&nbsp; a</span> memory module
which emulates the<i> memory on the Wild-Star </i>board. Before we can make
this work, we must perform two tasks.</p>

<p><span class=GramE>1)Reconcile</span> the interfaces between memory
operations on the CPU with memory operation for the Wild-One board hardware. As
you will see below, there are significant differences between the control
signals, bus structure, word format, and timing of these two interfaces.</p>

<p>2) Model and simulate the entire system (memory and CPU) in the simulator.</p>

<p>When you are done, this is a block diagram of what your design will look
like.</p>

<p class=MsoNormal align=center style='text-align:center'><img width=447
height=203 id="_x0000_i1028" src=myComp.jpg></p>

<p style='margin-top:0in;margin-right:.5in;margin-bottom:0in;margin-left:1.0in;
margin-bottom:.0001pt;text-indent:-.25in;mso-list:l0 level1 lfo2;tab-stops:
list .5in'><![if !supportLists]><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>The <i>CPU</i> block is your multi-cycle CPU
design from the previous unit.</p>

<p style='margin-top:0in;margin-right:.5in;margin-bottom:0in;margin-left:1.0in;
margin-bottom:.0001pt;text-indent:-.25in;mso-list:l0 level1 lfo2;tab-stops:
list .5in'><![if !supportLists]><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>The <i>Memory </i>block is a model of the
Wild-One board memory hardware. You can find this block in the COELib library
as the component &quot;memory_1502&quot;.</p>

<p style='margin-top:0in;margin-right:.5in;margin-bottom:0in;margin-left:1.0in;
margin-bottom:.0001pt;text-indent:-.25in;mso-list:l0 level1 lfo2;tab-stops:
list .5in'><![if !supportLists]><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><i>Memory Controller </i>is a block that you
will design to reconcile the timing and control signals between the two
interfaces.</p>

<p style='margin-top:0in;margin-right:.5in;margin-bottom:0in;margin-left:1.0in;
margin-bottom:.0001pt;text-indent:-.25in;mso-list:l0 level1 lfo2;tab-stops:
list .5in'><![if !supportLists]><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><i>Alignment Unit</i> is a block that you will
design to reconcile to memory word format between the two interfaces.</p>

<p><span class=GramE>Lets</span> take a detailed look at each of these units.</p>

<h3>Memory</h3>

<p class=MsoNormal>Memory serves as a storage space for your data and program.
The <i>Memory </i>block shown above is actually the memory_1502 component in
the COELib library. The symbol for this component is show below.</p>

<p align=center style='text-align:center'><!--[if gte vml 1]><v:shapetype id="_x0000_t75"
 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
 filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:362.25pt;
 height:159.75pt'>
 <v:imagedata src="Unit5_files/image001.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=483 height=213
src="Unit5_files/image002.jpg" v:shapes="_x0000_i1025"><![endif]></p>

<p>The address size of the memory model is 24-bits. This address selects a 64-bit
block of memory. When you add an instance of this component to your design, you
will notice a &quot;generic&quot; declaration attached with a pointer to a
file. Using this generic, it is possible to initialize the memory contents for
the memory model from a text file in the group project directory. You will use
this feature to load the memory with a test program to be executed. See the
section below on how to prepare this program. Once prepared, modify the generic
declaration that is included in the symbol file to point to the file that
contains your program and recompile the design.</p>

<h3>Memory Controller</h3>

<p class=MsoNormal>You may have noticed that the signals at the pin-out of the
Memory_1502 and the pin-out of your CPU do not match. In fact, they differ
significantly both in function and timing. The purpose of the <b>Memory
Controller </b>is to reconcile this difference. It will be a state machine that
accepts requests from the CPU for read or write operations, synchronizes the
CPU with the memory using the MEMWait signal, and manages the interface to the
memory model in order to make the transfer happen.</p>

<p>To understand how this will work, <span class=GramE>lets</span> begin with a
description of the memory interface signals coming to and from your CPU. These
are the signals shown to the right of the memory controller in the diagram
below. These read and write transfers and are the same whether your CPU is
doing an instruction fetch, a load, or a store operation. (<span class=GramE>except</span>
for differences in the read/write controls)</p>

<p>.</p>

<p class=MsoNormal align=center style='text-align:center'><img width=448
height=154 id="_x0000_i1029" src=memCtrl.jpg></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<h3>CPU to Memory Controller Interface</h3>

<p>Memory operations from the CPU proceed as follows. Refer to the
timingdiagram below.</p>

<p style='margin-top:1.5pt;margin-right:0in;margin-bottom:0in;margin-left:0in;
margin-bottom:.0001pt'><i>Clock cycle 1 </i>- the requested memory address is
placed on the MemoryAddress bus. One of MEMRead or MEMWrite becomes active for
a read or <span class=GramE>write</span> operation respectively.</p>

<p style='margin-top:1.5pt;margin-right:0in;margin-bottom:0in;margin-left:0in;
margin-bottom:.0001pt'><i>Clock cycle 2</i> - the memory controller asserts
MEMWait back to the CPU</p>

<p style='margin-top:1.5pt;margin-right:0in;margin-bottom:0in;margin-left:0in;
margin-bottom:.0001pt'>The CPU now holds in a wait state until the first clock
edge (<i>Cycle n)</i> after wait is de-asserted.</p>

<p style='margin-top:1.5pt;margin-right:0in;margin-bottom:0in;margin-left:0in;
margin-bottom:.0001pt'><i>Clock cycle n -</i> The memory controller places read
data on the data input bus and deasserts MEMWait. The CPU deasserts MEMRead and
latches the data into the input buffer register at the end of this cycle to
complete the read operation.</p>

<p>(Note - a practical design choice would be to have buffers on the input to
and the output from the CPU, however if you look at your CPU design you will
see that these buffers are already in place.)</p>

<p align=center style='text-align:center'><img width=625 height=287
id="_x0000_i1031" src=cpuMemRead.jpg></p>

<p align=center style='text-align:center'>TIMING DIAGRAM FOR CPU TO MEMORY
INTERFACE</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<h3>Memory Controller to MEMORY_1502 INTERFACE</h3>

<p class=MsoNormal>To write data to the SDRAM, first check that the
&#8216;write_rdy&#8217; signal is high. This step ensures that the write FIFOs
are not full. If &#8216;write_rdy&#8217; is high, the interface is ready to
accept write data. Next, put the address on the &#8216;addr&#8217; lines and
the 64-bit data on the &#8216;data_out&#8217; lines and then pulse
&#8216;write&#8217;. Data can be sent in continuously as long as &#8216;write_rdy&#8217;
is high. To read data back, first check that &#8216;read_rdy&#8217; is high to
make sure that the read address FIFOs are not full. Then, put the address on
the &#8216;addr&#8217; lines and pulse &#8216;read&#8217;. Again, the address
of data to be read can be continuously written into the interface as long as
&#8216;read_rdy&#8217; is high. Soon afterwards, the
&#8216;data_in_available&#8217;signal will go high. To get the read data, the
data_in_ce line must be pulsed (or held high to retrieve data continuously).
One clock later, data will be available on the &#8216;data in&#8217; <span
class=GramE>lines .</span></p>

<p>The waveform is shown below.</p>

<p><o:p>&nbsp;</o:p></p>

<p><!--[if gte vml 1]><v:shape id="_x0000_i1026" type="#_x0000_t75" style='width:765pt;
 height:461.25pt'>
 <v:imagedata src="Unit5_files/image003.jpg" o:title="read2"/>
</v:shape><![endif]--><![if !vml]><img width=1020 height=615
src="Unit5_files/image003.jpg" v:shapes="_x0000_i1026"><![endif]></p>

<p class=MsoNormal align=center style='text-align:center'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75"
 style='width:775.5pt;height:491.25pt'>
 <v:imagedata src="Unit5_files/image004.jpg" o:title="write2"/>
</v:shape><![endif]--><![if !vml]><img width=1034 height=655
src="Unit5_files/image004.jpg" v:shapes="_x0000_i1027"><![endif]></p>

<p>Notice, that simulated memory is <span class=GramE>small,</span> therefore
the address bus thatgoes to the Memory_1502 is <u>only 24 bits wide</u>.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<h3>Alignment logic</h3>

<p class=MsoNormal>The final block is this part of your design is the alignment
logic. This block has the function of reconciling the 64-bit word organization
of the memory with the byte addresses coming out of the CPU. The first step in
this process is to realize that each memory word contains eight bytes and thus
the address input to the memory model will always be the CPU address shifted
right by three bits. The low order three bits will select the particular byte
lane within the 64-bit word that is returned.</p>

<p>The second part of the problem has to do with the fact when the CPU asks for
a byte, it <i>always</i> expects that the byte with be in the low order 8-bits
of the input bus. However, unless the low order three bits of the address are
zero, this byte will not be in the low order byte lane of the memory word. The
function of the data alignment network is to examine the low order three bits
of the CPU address and in the case of LB instructions, shift the selected byte
lane of the incoming memory word to the low order byte.</p>

<p>An analogous problem arises for half-word (16 bits) accesses, since there
will be four 16-bit halfword lanes in each memory word.</p>

<p>Store byte and store half-word instructions present a special problem. If
the CPU asks to write a particular byte lane or half-word lane of a 64-bit
memory word, you must do so without overwriting the other parts of the memory
word. Thus, Store byte and Store halfword instructions must pre-read the
contents of the memory word in question, insert the byte or half-word and then
write the memory word. Do this last, but you will need to design both your
control unit and alignment network to handle this case.</p>

<p align=center style='text-align:center'><img width=576 height=288
id="_x0000_i1034" src=dataAlign.bmp border=0><br>
&nbsp;</p>

<h3>Building and Running a Test Program</h3>

<p>We mentioned above that it is possible to point the memory model to an
initialization file through the generic declaration attached to the symbol. We
will talk more about his in a moment. First, we need to look at how this file
can be created. As an diagnostic program for your design, we have written and
supplied a test program written in MIPs assembler called <span class=GramE><i>simpletest64.s</i>
.</span> To convince yourself how this program works, you may wish to download
a copy and run it in the PCPSPIM simulator. A full program listing with load
addresses and machine language shown is available in <i>simpletest64.lst</i>.
We have also prepared a loadable memory image of this program, with the first
instruction set up to load into memory location 0x000000. This file can be
found in <i>simpletest64.bin</i>. Note that this test assumes that your branch
is implemented so that <i>NextPC = PC + 4 * Offset</i>. </p>

<p>1) Make a copy of this file and place it in your group directory. </p>

<p>2) Modify the generic in your memory model component to point to this file.</p>

<p>3) Compile and run your design in the simulator. You should have setup your reset
line to force the PC to location zero. Start your simulation run by toggling
the reset line then monitor the memory data bus as the program executes. <span
class=GramE>When finished you can monitor the data transfer of the registers
back into memory to verify your results.</span> </p>

<p><b>Exception-enabled Simpletest files *YOU MUST RUN THESE FOR SUBMISSION*</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><a
href="../../../../../../~don/coe1502/current/Unit5/1502_Asm/simpletest64_v3/simpletest64_ex.lst">simpletest64_ex.lst</a>,
<a
href="../../../../../../~don/coe1502/current/Unit5/1502_Asm/simpletest64_v3/simpletest64_ex.s">simpletest64_ex.s</a>,
<a
href="../../../../../../~don/coe1502/current/Unit5/1502_Asm/simpletest64_v3/simpletest64_ex.bin">simpletest64_ex.bin</a></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p style='margin-bottom:12.0pt'><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>

<title>SQL DATA MANIPULATION LANGUAGE</title>
<h1>SQL DATA MANIPULATION LANGUAGE</h1>
<center><xs><a href="http://www.cs.pitt.edu/~chang/156/lecture/07a">Click here for part A of audio-text lecture and feed it to the speech agent</a></xs></center>
<br>
<center><xs><a href="http://www.cs.pitt.edu/~chang/156/lecture/07b">Click here for part B of audio-text lecture and feed it to the speech agent</a></xs></center>
<br>
<center><a href="http://blue.cs.ksi.edu/dl/cs156x/07.rm">Click here for an audio lecture that can be played using RealPlayer</a></center>
<br>
<li> DML statements
<br>
<br>SELECT
<br>UPDATE
<br>DELETE
<br>INSERT
<br>
<br>
<li> Simple Queries
<br>
<br>
SELECT S#, STATUS<br>
FROM S<br>
WHERE CITY = 'Paris' ;
<br>
<br>
<li> Qualified Names
<br>
SELECT S.S#, S.STATUS<br>
FROM S<br>
WHERE S.CITY = 'Paris' ;
<hr>
<h1>SIMPLE QUERIES</h1>
<br>
<li> Simple retrieval (projection)
<br>
SELECT P#<br>
FROM SP ;
<br>
<li> Eliminate duplicates
<br>
SELECT DISTINCT P#<br>
FROM SP ;
<br>
<li> Computed values
<br>
SELECT P.P#, 'Weight in grams =', P.WEIGHT * 234<br>
FROM P ;
<br>
<li> Select all columns
<br>
SELECT *<br>
FROM S ;
<br>
SELECT S.*<br>
FROM S ;
<br>
SELECT S.S#, S.SNAME, S.STATUS, S.CITY<br>
FROM S ;
<hr>
<h1>QUALIFIED RETRIEVAL</h1>
<br>
SELECT S#<br>
FROM   S<br>
WHERE  CITY = 'Paris'<br>
AND    STATUS > 20 ;
<br>
<li> The Condition is a logical expression
<pre>
     involving AND, OR, NOT, =, <>, >, >=, <, <=
</pre>
<br>
<br>
<li> Retrieval with ordering
<br>
<br>
SELECT S#, STATUS<br>
FROM   S<br>
WHERE  CITY = 'Paris'<br>
ORDER  BY STATUS DESC ;
<br>
<li> Select all columns with condition.
     (Restriction)
<br>
SELECT *<br>
FROM   S<br>
WHERE  CITY = 'Paris' ;
<hr>
<h1>JOIN QUERIES</h1>
<br>
<li> Join operation is the most powerful feature
     of the relational system.
<br>
<li> Use "join" to combine tables.
<br>
SIMPLE EQUIJOIN
<br>
SELECT S.*, P.*<br>
FROM   S, P<br>
WHERE  S.CITY = P.CITY ;
<br><br>
S TABLE<br>
S# SNAME STAT CITY<br>
<br><br>
P TABLE<br>
P# PNAME COLOR WGT CITY<br>
<br><br>
RESULT TABLE<br>
S# SNAME STAT S.CITY P# PNAME COLOR WGT P.CITY<br>
<br>
<li> S.CITY=P.CITY is called the "join condition"
<br>
<li> If one of the two IDENTICAL columns is
     eliminated, it is a "natural join".
<br>
SELECT S#,SNAME,STAT,S.CITY<br>
       P#,PNAME,COLOR,WGT<br>
FROM   S, P<br>
WHERE  S.CITY = P.CITY ;<br>
<br>
RESULT TABLE<br>
S# SNAME STAT S.CITY P# PNAME COLOR WGT <br>
<hr>
<h1>GENERALIZED JOINS</h1>
<br>
<li> Greater-than Join
<br>
SELECT S.*, P.*<br>
FROM   S, P<br>
WHERE  S.CITY > P.CITY ;<br>
<br>
<li> Additional conditions
<br>
SELECT S.*, P.*<br>
FROM   S, P<br>
WHERE  S.CITY = P.CITY<br>
AND    S.STATUS <> 20 ;<br>
<br>
<li> Selected fields
<br>
SELECT S.S#, P.P#<br>
FROM   S, P<br>
WHERE  S.CITY = P.CITY ;<br>
<br>
<li> Multiple tables
<br>
SELECT DISTINCT S.CITY, P.CITY<br>
FROM   S, SP, P<br>
WHERE  S.S# = SP.S#<br>
AND    SP.P# = P.P# ;<br>
<br>
<li> Joining a table with itself
<br>
SELECT FIRST.S#, SECOND.S#<br>
FROM   S FIRST, S SECOND<br>
WHERE  FIRST.CITY = SECOND.CITY<br>
AND    FIRST.S# < SECOND.S# ;<br>
<br>
(get all supplier pairs in same city)
<br>
<li> Notice the use of "range variables"
<hr>
<h1>AGGREGATE FUNCTIONS</h1>
<br>
COUNT - number of values in the column<br>
SUM - sum of the values in the column<br>
AVG - average of the values in the column<br>
MIN - minimum of the values in the column<br>
MAX - maximum of the values in the column<br>
<br>
<br>
<li> Get the total number of suppliers.
<br><br>
SELECT COUNT(*)<br>
FROM S ;<br>
<br>
<li> Get the total quantity of part P2 supplied.
<br>
SELECT SUM(QTY)<br>
FROM SP<br>
WHERE P# = 'P2' ;<br>
<hr>
<h1>GROUP BY</h1>
<br>
<li> Get the part # and total shipment quantity
     for each part.
<br>
SELECT P#, SUM(QTY)<br>
FROM SP<br>
GROUP BY P# ;<br>
<br>
RESULT:<br>
P1  600<br>
P2 1000<br>
P3  400<br>
P4  500<br>
P5  500<br>
P6  100<br>
<br>
<li> Get part numbers for all parts supplied
      by more than one supplier
<br>
SELECT   P#<br>
FROM     SP<br>
GROUP BY P#<br>
HAVING  COUNT(*) > 1 ;<br>
<br><br>
<li> HAVING is to groups what WHERE is to rows.<br>
<br><br>
<li> HAVING is used to eliminate groups, just as<br>
     WHERE is used to eliminate rows.<br>
<hr>
<h1>SUBQUERIES</h1>
<br><br>
<li> A subquery is an expression of the form<br>
     SELECT-FROM-WHERE-GROUP BY-HAVING<br>
     which is nested inside another such 
     expression.<br>
<br><br>
<li> We usually use subquery to represent a
     set of possible values to be searched in
     an "IN" condition.<br>
<br><br>
<li> Get supplier names for suppliers who
     supply part P2.<br>
<br><br>
SELECT SNAME<br>
FROM   S<br>
WHERE  S# IN<br>
   ( SELECT S#<br>
     FROM   SP<br>
     WHERE   P# = 'P2' ) ;<br>
<br><br>
SELECT SNAME<br>
FROM   S<br>
WHERE  S# IN {S1, S2, S3, S4} ;<br>
<hr>
<h1>QUERY EXAMPLE</h1>
<br>
Get supplier numbers for suppliers supplying at 
least one part supplied by at least one supplier
who supplies at least one read part.<br>
<br><br>
SQL Query:<br>
<br><br>
SELECT DISTINCT S#<br>
FROM SPJ<br>
WHERE P# IN<br>
 ( SELECT P#<br>
   FROM SPJ<br>
   WHERE S# IN<br>
      ( SELECT S#<br>
        FROM SPJ<br>
        WHERE P# IN<br>
          ( SELECT P#<br>
            FROM P<br>
            WHERE COLOR = "Red") ) )<br>
<hr><br>
<h1>STEP #1</h1>
<br>
          ( SELECT P#<br>
            FROM P<br>
            WHERE COLOR = "Red") ) )<br>
<br><br>
P TABLE<br>
<br><br>
P#	PNAME	COLOR	WEIGHT	CITY<br>
P1	Nut	Red	12	London<br>
P2	Bolt	Green	17	Paris<br>
P3	Screw	Blue	17	Rome<br>
P4	Screw	Red	14	London<br>
P5	Cam	Blue	12	Paris<br>
P6	Cog	Red	19	London<br>
<br><br>
PROJECTED AND RESTRICTED P TABLE<br>
<br><br>
P#<br>
P1<br>
P4<br>
P6<br>
<hr>
<h1>STEP #2</h1>
<br><br>
      ( SELECT S#<br>
        FROM SPJ<br>
        WHERE P# IN {P1, P4, P6}<br>
<br><br>
S# P# J# QTY<br>
S1 P1 J1 200*<br>
S1 P1 J4 700*<br>
S1 P3 J1 400<br>
S2 P3 J2 200<br>
S2 P3 J3 200<br>
S2 P3 J4 500<br>
S2 P3 J5 600<br>
S2 P3 J6 400<br>
S2 P3 J7 800<br>
S2 P5 J2 100<br>
S3 P3 J1 200<br>
S3 P4 J2 500*<br>
S4 P6 J3 500*<br>
S4 P6 J7 500*<br>
S5 P2 J2 200<br>
S5 P2 J4 100<br>
S5 P5 J7 100<br>
S5 P6 J2 200*<br>
S5 P1 J4 100*<br>
S5 P3 J4 200<br>
S5 P4 J4 800*<br>
S5 P5 J4 400<br>
S5 P6 J4 500*<br>
<hr>
<h1>STEP #3</h1>
<br><br>
 ( SELECT P#<br>
   FROM SPJ<br>
   WHERE S# IN {S1,S3,S4,S5}<br>
<br><br>
S# P# J# QTY<br>
S1 P1 J1 200*<br>
S1 P1 J4 700*<br>
S1 P3 J1 400*<br>
S2 P3 J2 200<br>
S2 P3 J3 200<br>
S2 P3 J4 500<br>
S2 P3 J5 600<br>
S2 P3 J6 400<br>
S2 P3 J7 800<br>
S2 P5 J2 100<br>
S3 P3 J1 200*<br>
S3 P4 J2 500*<br>
S4 P6 J3 500*<br>
S4 P6 J7 500*<br>
S5 P2 J2 200*<br>
S5 P2 J4 100*<br>
S5 P5 J7 100*<br>
S5 P6 J2 200*<br>
S5 P1 J4 100*<br>
S5 P3 J4 200*<br>
S5 P4 J4 800*<br>
S5 P5 J4 400*<br>
S5 P6 J4 500*<br>
<hr>
<h1>STEP #4</h1>
<br><br>
SELECT DISTINCT S#<br>
FROM SPJ<br>
WHERE P# IN {P1,P2,P3,P4,P5,P6}<br>
<br><br>
S# P# J# QTY<br>
S1 P1 J1 200*<br>
S1 P1 J4 700*<br>
S1 P3 J1 400*<br>
S2 P3 J2 200*<br>
S2 P3 J3 200*<br>
S2 P3 J4 500*<br>
S2 P3 J5 600*<br>
S2 P3 J6 400*<br>
S2 P3 J7 800*<br>
S2 P5 J2 100*<br>
S3 P3 J1 200*<br>
S3 P4 J2 500*<br>
S4 P6 J3 500*<br>
S4 P6 J7 500*<br>
S5 P2 J2 200*<br>
S5 P2 J4 100*<br>
S5 P5 J7 100*<br>
S5 P6 J2 200*<br>
S5 P1 J4 100*<br>
S5 P3 J4 200*<br>
S5 P4 J4 800*<br>
S5 P5 J4 400*<br>
S5 P6 J4 500*<br>
<hr>
<h1>QUERY EXAMPLE</h1>
<br><br>
Get supplier numbers for suppliers supplying at 
least one part supplied by at least one supplier
who supplies at least one red part.<br>
<br><br>
SQL Query:<br>
<br><br>
SELECT DISTINCT S#<br>
FROM SPJ<br>
WHERE P# IN<br>
 ( SELECT P#<br>
   FROM SPJ<br>
   WHERE S# IN<br>
      ( SELECT S#<br>
        FROM SPJ<br>
        WHERE P# IN<br>
          ( SELECT P#<br>
            FROM P<br>
            WHERE COLOR = "Red") ) )<br>
<br><br>
ANSWER: {S1,S2,S3,S4,S5}<br>
<hr>
<h1>QUERY EXAMPLE</h1>
 <br>
Query: Get part numbers for parts supplied<br>
by a supplier in London.<br>
 <br>
SELECT DISTINCT P#<br>
FROM   SPJ, S<br>
WHERE  SPJ.S# = S.S#<br>
AND    CITY = 'London' ;<br>
 <br>
 <br>
S# P# J# QTY CITY   SNAME STATUS<br>
S1 P1 J1 200 London	...<br>
S1 P1 J4 700 London	...<br>
S1 P3 J1 400 London	...<br>
S4 P6 J3 500 London	...<br>
S4 P6 J7 500 London	...<br>
 <br>
ANSWER: {P1, P3, P6}<br>
.<br>
<hr>
<h1>QUERY EXAMPLE</h1>
 <br>
Query: Get all pairs of part numbers such
that some supplier supplies both the
indicated parts.<br>
 <br>
SELECT SPJX.P#, SPJY.P#<br>
FROM   SPJ SPJX, SPJ SPJY<br>
WHERE  SPJX.S# = SPJY.S#<br>
AND    SPJX.P# > SPJY.P# ;<br>
 <br>
SPJ TABLE<br>
S# P# J# QTY<br>
S1 P1 J1 200	(P1,P3)<br>
S1 P1 J4 700<br>
S1 P3 J1 400<br>
S2 P3 J2 200	(P3,P5)<br>
S2 P3 J3 200<br>
S2 P3 J4 500<br>
S2 P3 J5 600<br>
S2 P3 J6 400<br>
S2 P3 J7 800<br>
S2 P5 J2 100<br>
S3 P3 J1 200	(P3,P4)<br>
S3 P4 J2 500<br>
S4 P6 J3 500	?<br>
S4 P6 J7 500<br>
S5 P2 J2 200	?<br>
S5 P2 J4 100<br>
S5 P5 J7 100<br>
S5 P6 J2 200<br>
S5 P1 J4 100<br>
S5 P3 J4 200<br>
S5 P4 J4 800<br>
S5 P5 J4 400<br>
S5 P6 J4 500<br>
<hr>
<h1>QUERY EXAMPLE</h1>
 <br>
Query: Get part numbers of parts supplied 
to some project in an average quantity of
more than 320.<br>
 <br>
SELECT DISTINCT P#<br>
FROM   SPJ<br>
GROUP  BY P#, J#<br>
HAVING AVG(QTY) > 320 ;<br>
 <br>
SPJ TABLE AFTER GROUPING<br>
 <br>
S# P# J# QTY<br>
S1 P1 J1 200<br>
 <br>
S5 P1 J4 100<br>
S1 P1 J4 700<br>
 <br>
S5 P2 J2 200<br>
 <br>
S5 P2 J4 100<br>
 <br>
S1 P3 J1 400<br>
S3 P3 J1 200<br>
<hr>
<h1>S# P# J# QTY</h1>
S1 P1 J1 200<br>
S1 P1 J4 700<br>
S1 P3 J1 400<br>
S2 P3 J2 200<br>
S2 P3 J3 200<br>
S2 P3 J4 500<br>
S2 P3 J5 600<br>
S2 P3 J6 400<br>
S2 P3 J7 800<br>
S2 P5 J2 100<br>
S3 P3 J1 200<br>
S3 P4 J2 500<br>
S4 P6 J3 500<br>
S4 P6 J7 500<br>
S5 P2 J2 200<br>
S5 P2 J4 100<br>
S5 P5 J7 100<br>
S5 P6 J2 200<br>
S5 P1 J4 100<br>
S5 P3 J4 200<br>
S5 P4 J4 800<br>
S5 P5 J4 400<br>
S5 P6 J4 500<br>
<hr>
<h1>S TABLE</h1>
 <br>
S#	SNAME	STATUS	CITY<br>
S1	Smith	20	London<br>
S2	Jones	10	Paris<br>
S3	Blake	30	Paris<br>
S4	Clark	20	London<br>
S5	Adams	30	Athens<br>
<hr>
<h1>P TABLE</h1>
<br><br>
P#	PNAME	COLOR	WEIGHT	CITY<br>
P1	Nut	Red	12	London<br>
P2	Bolt	Green	17	Paris<br>
P3	Screw	Blue	17	Rome<br>
P4	Screw	Red	14	London<br>
P5	Cam	Blue	12	Paris<br>
P6	Cog	Red	19	London<br>
<hr>
<h1>J TABLE</h1>
 <br>
J#	JNAME	CITY<br>
J1	Sorter	Paris<br>
J2	Punch	Rome<br>
J3	Reader	Athens<br>
J4	Console	Athens<br>
J5	CollatorLondon<br>
J6	TerminalOslo<br>
J7	Tape	London<br>
<hr>
<h1>ADVANCED FEATURES</h1>
<br><br>
<li> Retrieval using LIKE for string matching<br>
<br><br>
Get all parts whose names begin with 'C'.<br>
<br><br>
SELECT P.*<br>
FROM P<br>
WHERE P.PNAME LIKE 'C%' ;<br>
<br><br>
<li> '_' any single character<br>
<br><br>
<li> '%' any sequence of characters<br>
<br><br>
<hr>
<h1>RETRIEVAL INVOLVING NULL</h1>
<br><br>
Get supplier numbers for suppliers
with status greater than 25.<br>
<br><br>
SELECT S#<br>
FROM   S<br>
WHERE  STATUS > 25;<br>
<br><br>
<li> If a record has STATUS equal to NULL,
     it will NOT qualify, because
     NULL does NOT match ANYTHING.<br>
<hr>
<h1>QUERY USING EXISTS</h1>
<br><br>
<li> EXISTS represents the existential
     quantifier in logic
<br><br>
Get supplier names for suppliers who
supply part P2.<br>
<br><br>
SELECT SNAME<br>
FROM   S<br>
WHERE  EXISTS<br>
 ( SELECT *<br>
   FROM   SP<br>
   WHERE  S# = S.S#<br>
   AND    P# = 'P2' ) ;<br>
<hr>
<h1>UPDATE OPERATIONS</h1>
<br><br>
UPDATE table<br>
SET    field = scalar-expression<br>
        [, field = scalar-expression ] ...<br>
[ WHERE condition ] ;<br>
<br><br>
Change the color of part P2 to yellow,
and increase weight by 5, and
set city to "unknown".<br>
<br><br>
UPDATE P<br>
SET    COLOR = 'Yellow',<br>
       WEIGHT = WEIGHT + 5,<br>
       CITY = NULL<br>
WHERE  P# = 'P2' ;<br>
<hr>
<h1>DELETE AND INSERT</h1>
<br><br>
Delete supplier S5.<br>
<br><br>
DELETE<br>
FROM    S<br>
WHERE   S# = 'S5' ;<br>
<br><br>
Insert a new record to table P.<br>
<br><br>
INSERT<br>
INTO    P  ( P#, CITY, WEIGHT )<br>
VALUES    ( 'P7', 'Athens', 24 );<br>
<hr>
<h1>SQL DATA DEFINITION LANGUAGE</h1>
<br><br>
<li> DDL statements<br>
<br><br>
CREATE TABLE<br>
CREATE VIEW<br>
CREATE INDEX<br>
<br><br>
ALTER TABLE<br>
<br><br>
DROP TABLE<br>
DROP VIEW<br>
DROP INDEX<br>
<br><br>
<hr>
<h1>CREATE TABLE</h1>
<br><br>
CREATE TABLE base-table<br>
 ( column-definition [, column-definition ] ...<br>
  [, primary-key-definition ]<br>
  [, foreign-key-definition<br>
     [, foreign-key-definition ]...]);<br>
<br><br>
Where column-definition is<br>
  column data-type [ NOT NULL ]<br>
<br><br>
CREATE TABLE S<br>
  ( S#                CHAR(5) NOT NULL,<br>
    SNAME             CHAR(20) NOT NULL,<br>
    STATUS            SMALLINT NOT NULL,<br>
    CITY              CHAR(15) NOT NULL,<br>
  PRIMARY KEY ( S# ) );<br>
<br><br>
<li> Data Types<br>
<br><br>
INTEGER, SMALLINT, DECIMAL(p,q), FLOAT<br>
CHAR(n),VARCHAR(n),GRAPHIC(n),VARGRAPHIC(n)<br>
DATE, TIME, TIMESTAMP<br>
<hr>
<h1>ALTER TABLE</h1>
<br><br>
ALTER TABLE base-table ADD column data-type ;<br>
<br><br>
ALTER TABLE S ADD DISCOUNT SMALLINT ;<br>
<br><br>
<li> Effects of adding columns<br>
<br><br>
When a record is read from disk, nulls
are added to the added fields<br>
<br><br>
When a record is written to the disk,
the expanded version is written<br>
<br><br>
<li> Effects of dropping columns<br>
<br><br>
Not supported by DB2<br>
<br><br>
DROP TABLE<br>
<br><br>
DROP TABLE base-table ;<br>
<hr>
<h1>INDEXES</h1>
<br><br>
<li> User can create indexes.  But DB2 decides
     whether to use indexes or not.<br>
<br><br>
CREATE [ UNIQUE ] INDEX index<br>
  ON base-table<br>
  ( column [ order ] [, column [ order ]]...)<br>
    [ CLUSTER ] ;<br>
<br><br>
<li> order can be ASC (ascending) or
     DESC (descending)
     or unspecified (ascending by default)<br>
<br><br>
<li> CLUSTER is cluster index.
     Each table can have at most one.<br>
<br><br>
CREATE INDEX X ON T (P, Q DESC, R) CLUSTER;<br>
<br><br>
<li> UNIQUE means no two records in the
     indexed table have identical indexed
     field (or fields).<br>
<br><br>
CREATE UNIQUE INDEX XS ON S ( S# ) ;<br>
<br><br>
<li> DBS requires unique index on every
     primary key.<br>
<br><br>
CREATE INDEX XSC ON S ( CITY ) ;<br>
<br><br>
<li> XSC is not unique index.<br>
<br><br>
DROP INDEX XSC ;<br>
<hr>

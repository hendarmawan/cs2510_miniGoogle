   PROFESSOR:  NOW, STARTING TODAY, WE WILL
BE DISCUSSING THE TWO PROJECTS.  LIKE I
MENTIONED LAST TIME, YOU NEED NOT DO BOTH.
YOU ONLY NEED TO DO THE FIRST -- ONLY ONE.
AND TODAY WE WILL BE DISCUSSING THE FIRST
PROJECT.  NOW THE FIRST PROJECT ACTUALLY
IN A WAY IT'S EASIER, QUOTE, UNQUOTE.
BECAUSE IT'S A VERY CLEAN, AGAIN QUOTE,
UNQUOTE, CLEAN PROJECT.  THE REASON I SAY
SO IS THAT THIS PROJECT IS FOR YOU TO
WRITE SQL LANGUAGE INTERPRETER, SO
EVERYTHING'S UNDER YOUR CONTROL.  YOU CAN
USE ANY PROGRAMMING LANGUAGE OF YOUR
CHOICE, VISUAL BASIC, VISUAL C PLUS PLUS,
WHATEVER.  THEREFORE, IT DOESN'T REQUIRE
THAT YOU INSTALL THE WEB BASED SYSTEM AND
TRY TO DEAL WITH A LOT OF INSTALLATION
PROBLEMS.  SO THIS IS A VERY CLEAN
PROBLEM.  AND ALSO THE FACT THAT YOU CAN
START NOW, GIVE YOU A WHOLE MONTH TO WORK
ON THE PROJECT.  LET ME AGAIN REMIND YOU
THE SCHEDULE.  SO THE EARLY BIRD DEADLINE
IS NOVEMBER 28 AND TODAY IS OCTOBER 31.
SO YOU HAVE ABOUT A WHOLE MONTH.  SO IF
YOU START WORKING ON IT NOW, AND IF YOU
CAN TURN IN YOUR PROJECT, BY THE EARLY
BIRD DEADLINE, YOU WILL EARN THREE EXTRA
POINTS.  SO FOR THIS PROJECT, IT'S QUITE
EASY TO EARN ELEVEN, TWELVE POINTS.  I
MEAN YOUR BASIC POINTS PLUS THE THREE
EXTRA CREDIT.  OKAY?  SO THIS IS WORTH FOR
YOU TO CONSIDER IF YOU WANT TO MAKE UP FOR
SOME DEFICIENCY.  LET'S SAY YOU HAVE A BAD
MIDTERM OR IF YOU DID NOT TURN IN ONE OF
THE EXERCISES, THIS IS A VERY GOOD WAY TO
MAKE IT UP.
     THE SECOND PROJECT, OF COURSE, IS
ALSO VERY INTERESTING.  BUT IT DOES
REQUIRE A LOT OF INSTALLATION, SYSTEM TYPE
OF PROBLEMS, SO DEPENDING UPON YOUR
CHOICE, AND ANOTHER THING IS THAT I WILL
BE DISCUSSING THE NEXT, THE SECOND
PROJECT, ONLY NEXT WEEK.  SO IF YOU START
ON THIS ONE, YOU GET ADVANTAGE OF AT LEAST
A WEEK.  AND TODAY I EXPLAIN TO YOU THE
DETAILS OF WHAT I EXPECT FROM THIS
PROJECT.
     OKAY.  I WANT YOU TO WRITE A PROGRAM
SO THAT THE PROGRAM CAN ACCEPT AS INPUT AN
SQL QUERY AND TRANSLATE THAT QUERY INTO
RELATIONAL ALGEBRA.  THAT'S THE BASIC
PROJECT.  THE BONUS PART IS FOR YOU TO
IMPLEMENT AT LEAST ONE OF THE THREE
OPERATORS SO THAT IT CAN ACTUALLY DO
TRANSLATION AS WELL AS EXECUTION.  SO IF
YOU DO EVERYTHING, YOU CAN EARN UP TO 16
POINTS.  THAT'S A LOT OF POINTS.
     NOW THE OTHER PROJECT I WON'T SAY SO.
IT'S NOT THAT EASY TO EARN ALL 16 POINTS.
OKAY.
     SO WHAT KIND OF QUERY I ACCEPT YOU TO
TRANSLATE?  WE ALL NOW BY NOW THAT THE SQL
LANGUAGE IS ESPECIALLY CLEAN SYNTAX.
SELECT, FROM, WHERE.
     AND A SIMPLE SEQUEL QUERY WILL LOOK
LIKE THAT ALONG THE SELECT, THE NAME OF
THE SUPPLIER FROM THE SUPPLIER RELATION
WHERE, THE STATUS OF THE SUPPLIER'S EQUAL
TO 20.  SOMETHING LIKE THAT.  NOW, BY A
SIMPLE SQL QUERY I MEAN ONE WITHOUT ANY
NESTING.  EXAMPLES I GIVE BEFORE, SELECT,
FROM, WHERE, SELECT, FROM, WHERE.  THAT
BECOMES COMPLICATED TO TRANSLATE, SO WHAT
I LIKE TO DEAL WITH IS A LIST VERY SIMPLE
QUERIES LIKE THIS, YOU CAN EVEN FURTHER
SIMPLIFY THAT AT LEAST TO GET YOU STARTED,
LET'S SAY I HAVE ONLY A LIST OF ATTRIBUTES
TO RETRIEVE.  HERE IS THE LIST OF
RELATIONS, THAT BEGIN WITH JUST ONE.  AND
THEN HERE WE HAVE A NUMBER OF CLAUSES,
THESE ARE THE CONDITIONS, RIGHT?  TO BEGIN
WITH ALSO JUST ONE.  OKAY?  THAT'S THE
SIMPLEST FORM OF QUERY THAT WE CAN
PROCESS.
     SO, SUPPOSE YOU WRITE YOUR PROGRAM,
SO THE PROGRAM ACCEPTS AS INPUT THIS QUERY
AND TRY TO TRANSLATE THAT INTO THE OUTPUT
QUERY INTO RELATIONAL ALGEBRA, INTO
ALGEBRA QUERY.  WE NOTICE THAT THIS SQL
QUERY LANGUAGE BASICALLY HAS THESE THREE
KEY WORDS SO, WHAT SHOULD WE DO IN ORDER
TO DO THE TRANSLATION?
     STUDENT:   PARSE IT OUT.
     PROFESSOR:   AND PARSING SOMETIMES
REQUIRES SIN TAX DIRECTED SYNTAX APPROACH,
REQUIRES GRAM MA MAR, THIS IS SOME SIMPLE
YOU DON'T NEED GRAMMAR JUST DETECT KEY
WORDS.  SO BASICALLY WHAT YOU CAN DO IS
JUST TRY TO DETECT THE THREE KEY WORDS,
AND THEN WHAT FOLLOWS THE KEY WORD WILL BE
THE ATTRIBUTE NAME STRING, THE RELATION
NAME STRING AND THE CONDITION STRING.
OKAY?  SO, YOU COULD DO A PARSER BUT THE
SIMPLEST WAY IS TO JUST DETECT THE THREE
KEY WORDS, WHICH I DON'T THINK ANYONE HAS
ANY PROBLEM.  SO BASICALLY WHAT YOU HAVE
IS SOMETHING LIKE THAT. SELECT STRING ONE
FROM, STRING TWO, WHERE, STRING 3.  SO YOU
DETECT THE KEY WORDS AND THEN YOU ISOLATE
THE THREE STRINGS.
     NOW, OUR OBJECTIVE IS TO TRANSLATE
THE QUERY INTO THE CORRESPONDING
RELATIONAL ALGEBRAIC COMMANDS.  THE
ALGEBRA AS WE ALREADY LEARNED WE CAN USE A
NUMBER OF NOTATIONS.  IT'S YOUR CHOICE,
BUT JUST FOR THE EXAMPLE, LET ME USE A
NOTATION I USE IN THE NOTES, BUT FEEL FREE
TO CHOOSE A DIFFERENT NOTATION IF YOU
DON'T LIKE THIS NOTATION.
     SO FOR THIS QUERY, WHAT'S THE
TRANSLATION?  YOU ALREADY DID QUITE A FEW
EXERCISES ON THIS, THIS QUERY.  I'M
LOOKING FOR THE EQUIVALENT RELATIONAL
ALGEBRAIC STATEMENTS.  MAYBE I START WITH
YOU.
     STUDENT:   IT'S YOU WANT TO PROJECT
OUT THE S NAME, SO I GUESS PI.
     PROFESSOR:   YES, PI OF NAME FROM S.
     STUDENT:   FOR S WHERE STATUS EQUAL
T1.
     PROFESSOR:   IF YOU DO THAT TO BEGIN
WITH YOU YOU WILL LOSE OTHER ATTRIBUTES,
YOU REALIZE THAT?
     STUDENT:   I THOUGHT WE WERE JUST
SELECTING THE NAME.
     PROFESSOR:   OKAY.  INSIDE HERE YOU
WANT TO DO SOMETHING, RIGHT?
     STUDENT:   RIGHT.  YEAH STATUS EQUAL
20 FROM S.
     PROFESSOR:   RIGHT.  FROM THIS
RELATION S, RIGHT?  OKAY.  AND THAT
WILL -- IF YOU ALLOW ME TO WRITE IT IN THE
LONG FORM, I WILL PROBABLY WRITE SOMETHING
LIKE THIS, T1 IS BASICALLY I'M TRYING TO
RESTRICT TO STATUS EQUAL TO 20 AND THEN I
DO A PROJECT WHERE THE TARGET IS NAME.  I
WRITE IN TWO LINES.  OKAY.
     SUPPOSE IN GENERAL MY INPUT IS LIKE
THIS.  I USE THE KEY WORD DETECTION,
DETECT THE THREE KEY WORDS AND I KNOW THE
STRINGS THAT FOLLOWS.  AND IN FACT, MY
TRANSLATION WOULD IN GENERAL LOOK LIKE
THIS.  T1 IS EQUAL TO THE NAME OF THE
RELATION FOLLOWED BY A CONDITION AND THEN
T2 IS FOLLOWED BY AN ATTRIBUTE LIST.
QUESTION, WHAT IS R?  STRING 1, 2, 3?
     STUDENT:   3.
     PROFESSOR:   STRING 3.  RIGHT.  SO
ALL WE HAVE TO DO IS TO PLUG IN STRING 3.
HOW ABOUT THIS?
     STUDENT:   2.
     PROFESSOR:   I'M SORRY, STRING 2.
AND HOW ABOUT CONDITION?
     STUDENT:   STRING 3.
     PROFESSOR:   STRING 3.  AND OF
COURSE, ATTRIBUTES IS STRING 1.  THIS IS A
VERY SIMPLE EXAMPLE OF PATTERN MATCHING.
IN OTHER WORDS, THE TECHNIQUE YOU CAN USE
IS TO DO PATTERN MATCHING SO YOU FOUND THE
STRINGS AND YOU PLUG INTO CONSTRUCT THE
RESULTING PATTERN.  IF YOU DO JUST THIS,
OKAY, YOU WILL GET FOUR OF THE SIX POINTS.
LATER ON I TALK ABOUT HOW I GRADE, OKAY,
BUT CORRECTNESS, THE MAXIMUM IS SIX.  IF
YOU JUST DO THIS VERY SIMPLE MINDED THING,
YOU WILL GET FOUR POINTS.  QUESTION?
     STUDENT:   WE HAVE TO USE C PLUS PLUS
FOR THIS?
     PROFESSOR:   ANYTHING.
     STUDENT:   YOU CAN USE PEARL?
     PROFESSOR:   BECAUSE OF THE PATTERN
MATCHING, YEAH, SURE, WHY NOT.  IT'S NOT
EASY TO USE ELEGANT TO DO INTERFACE.
WE'LL TALK ABOUT THAT.  WHATEVER YOU FEEL
COMFORTABLE.
     STUDENT:   WHAT'S THE MOST COMPLEX
SQL STATEMENT?
     PROFESSOR:   I'M COMING TO THIS THAT.
I'M DOING THAT ONE STEP AT A TIME.  IN
OTHER WORDS, EVERYBODY SHOULD BE ABLE TO
DO THIS.  THAT'S WHY THIS PROJECT IS GOOD.
BUT I THINK IT'S GOOD BECAUSE THIS WILL
ENABLE US TO LEARN THE BASIC PRINCIPLES OF
PATTERN MATCHING.  LET ME REPEAT.  THE
SIMPLEST FORM OF QUERY SHOULD BE ABLE TO
DEAL WITH SELECT, FROM, WHERE.  WITH A
LIST OF ATTRIBUTES HERE, WITH A SINGLE
RELATION NAME AND A SINGLE CONDITION.
THESE ARE JUST THREE STRINGS, SO YOU
ISOLATE A STRINGS AND THEN YOU PLUG IT IN
INTO A TEMPLATE, YOU CONSTRUCT THE RESULT.
NO PROBLEM, RIGHT?  YEAH?
     STUDENT:   I THOUGHT THIS WAS
ACTUALLY GOING TO BE PULLING THINGS FROM
FILES?
     PROFESSOR:   YEAH, I'M COMING TO
THAT.
     STUDENT:   DO YOU HAVE TO CONVERT IT
INTO RELATIONAL ALGEBRA OR USE WHAT YOU
HAVE FROM THE SQL COMMANDS, THE ACTUAL SQL
STATEMENTS, COULDN'T YOU JUST DO THE
QUERIES ON DATABASE BEFORE, WITHOUT
EVEN --
     PROFESSOR:   NO, NO.  I WANT TO YOU
WRITE THIS SQL INTERPRETER.
     STUDENT:   RIGHT.
     PROFESSOR:   IF YOU USE EXISTING SQL
SYSTEM IT DEFEATS PURPOSE.
     STUDENT:   NO  .
     IF YOU HAD A COMMAND PROMPT AND TYPE
SQL COMMANDING PROMPTS THAT YOU CREATE
YOURSELF YOU HAVE TO CONVERT IT INTO
RELATIONAL ALGEBRA?
     PROFESSOR:   YEAH.  THAT'S WHAT I ASK
YOU TO DO, YEAH.  ALWAYS, SOME OF YOU MAY
BE THINKING ABOUT EDITOR, THAT'S TOO EASY.
LET'S ASSUME THE QUERY COMES FROM
SOMEWHERE OUTSIDE, OKAY?  OTHERWISE, IF
YOU STRUCTURE EDITOR EVERYTHING IS ALREADY
GIVEN.
     SO THIS IS DOABLE FOR EVERYBODY,
SHOULD BE.  AND THEN OF COURSE YOU CAN
START REFINING THAT, OKAY, BASICALLY, WHAT
I LIKE TO BE ABLE TO DEAL WITH IS THAT I
WILL HAVE A LIST OF ATTRIBUTES HERE, I
HAVE MAYBE MORE THAN ONE, SUPPLIER PART
RELATIONS HERE AND I WILL HAVE SEVERAL, IN
THE WHERE PART I WILL HAVE SEVERAL
CONDITIONS BUT THEY ARE ALWAYS OF THIS
FORM.  SO S.NAME EQUALS S1 AND I DON'T
CARE HOW YOU WRITE A CONJUNCTION, AND OR
USING SOME OTHER NOTATION AND THEN FOR
EXAMPLE, S NUMBER EQUAL TO -- SORRY.  SP.S
NUMBER, AND.  NO, NO MORE AND.  SUPPLY
NAME, S1, S NUMBER, S NUMBER.  MAYBE I
WANT THE PART NAME UP HERE.
     SO THIS QUERY WILL SELECT THE NAME OF
THE PART FROM THE TWO RELATIONS S AND SP,
WHERE, S.NAME EQUAL S1 AND S NUMBER FROM S
EQUAL TO S NUMBER FROM S P.
     STUDENT:   YOU'RE MISSING TABLE P,
THOUGH.
     STUDENT:   YEAH.
     PROFESSOR:   I DID NOT USE THE TABLE
P, DID I?
     STUDENT:   YOU'RE ASKING FOR THE
P.NAME.
     PROFESSOR:   SO THE QUERY IS MORE
COMPLICATED.
     STUDENT:   SP IS JUST --
     PROFESSOR:   WHY NOT, LET ME DO THIS.
     I NEED TO HAVE MORE.  I HAVE TO HAVE
P.P NUMBER EQUALS SP.P NUMBER.  THANK YOU.
OKAY.  ANYWAY, THE POINT I TRY TO MAKE IS
THAT YOU HAVE TWO TYPE OF CONDITIONS HERE
AND IT'S EASILY DETECTABLE.  ONE TYPE HAVE
YOU ATTRIBUTE NAME ON ONE SIDE AND A
LITERAL VALUE ON THE OTHER SIDE.  AND THIS
IS TREATED AS THE WHAT YOU SHOULD
RESTRICT.  THE OTHER TYPE IS THE EQUAL
JOIN.  THE JOIN WE CAN DETECT THAT BECAUSE
WE MUST HAVE ATTRIBUTE NAMES ON EITHER
SIDE OF THE QUANTITY.
     STUDENT:   SO THE JOIN CONDITION IS
ALSO GOING TO BE GIVEN TO US IN THE SQL
STATEMENT?
     PROFESSOR:   HERE?  WHAT DO YOU MEAN
ALWAYS GIVEN TO YOU?
     STUDENT:   IF THERE IS TWO TABLES
BEING JOINED TOGETHER THE JOIN CONDITION
WILL ALWAYS BE GIVEN TO US?
     PROFESSOR:   CORRECT.  IN OTHER
WORDS, WE WILL GIVE YOU WELL, THE USER
WILL FORM THE QUERY THAT WAY, NOTHING IS
MISSING.
     STUDENT:   AND DO YOU CARE IF WE USE
NATURAL JOIN OR LIST OF JOIN?
     PROFESSOR:   YEAH, IT SHOULD BE
ALWAYS A NATURAL JOIN.
     I KNOW WHAT YOU'RE LEADING TO.  IN
OTHER WORDS, IF YOU REALLY WRITE A GOOD
INTERPRETER YOU CAN LEAVE THOSE THINGS
OUT, BUT LET'S ASSUME THESE THINGS ARE IN,
BECAUSE I'M GOING TO BE COUNTING ON THAT
BECAUSE THIS MEANS A JOIN.  THIS MEANS A
RESTRICT, OKAY?  IN OTHER WORDS, YOU CAN
SEE THAT THIS IS STILL PATTERN MATCHING,
OKAY?  OKAY?
     SO, OF THE SIX POINTS, IF YOU CAN DO
WHAT I MENTIONED EARLIER, VERY SIMPLE
QUERY, YOU ALREADY GET FOUR.  AND IF YOU
CAN DO MORE COMPLEX QUERIES LIKE THIS,
YOU'LL GET FIVE AND SIX WHEN YOU ARE
DEALING WITH MULTIPLE TABLES.
     OKAY?  FAIR ENOUGH?
     STUDENT:   WHAT'S THE DIFFERENCE
BETWEEN FIVE AND SIX?
     PROFESSOR:   FIVE IS YOU HAVE
MULTIPLE CONDITIONS BUT THEY MAY BE ALL
CONDITIONS LIKE THIS -- OKAY?  BECAUSE YOU
CANNOT HAVE JOIN CONDITION UNLESS HAVE YOU
MULTIPLE TABLES.  SIX IS THAT YOU HAVE
MULTIPLE TABLES, IN WHICH CASE YOU COULD
HAVE JOIN CONDITIONS.  EVERYBODY WITH ME?
OKAY.  GOOD.
     CAN YOU TURN OFF THE LIGHT?
REQUIREMENT IS TO WRITE THIS-FIRST OFF
QUERY, INTERPRET THE QUERY AND BE ABLE TO
TRANSLATE INTO RELATIONAL ALGEBRA
STATEMENTS.
     WHEN YOU TURN IT IN, IN FACT, FOR THE
PROJECT, YOU ARE GOING TO GIVE A LIFE DEMO
TO ME, EACH ONE OF YOU.  SO WE WILL
SCHEDULE AND I KNOW SOME OF YOU ARE
WORKING, I WILL SCHEDULE INTO EVENING IF
NECESSARY, SO EACH PERSON WILL COME TO MY
OFFICE, YOU CAN BRING YOUR OWN NOTEBOOK,
IF YOU LIKE, BECAUSE THIS WILL MAKE THINGS
EASIER.  OF COURSE I HOPE YOU DON'T BRING
YOUR WHOLE PC, THAT WEIGHS A TON.  JUST A
NOTEBOOK LAPTOP, AND GIVE ME A DEMO.  YOU
SHOULD CREATE BEFOREHAND SOME QUERIES.
BECAUSE IF YOU GIVE ME A DEMO ON THE SPOT,
TYPE INTO SOME QUERIES, GET NERVOUS, YOU
WILL SCREW UP THE WHOLE THING.  I WANT TO
YOU PREPARE SOME QUERY FORMS, F1, Q2 IN
THE QUERY FILE, YOU STORE QUERIES
BEFOREHAND.  AND THE RESULTS SHOULD ALSO
GO INTO FILES, T1, T2, ET CETERA, AND THEN
YOU CAN RUN YOUR PROGRAM.  OKAY.  TURN ON
THE LIGHT, PLEASE.
     SUPPOSE MY QUERY IS SELECT NAME FROM
X WHERE S PLUS STATUS IS EEL WALL TO 20.
IF I JUST DO THE PATTERN MATCHING, I
DISCUSSED A MOMENT AGO, I WILL TRANSLATE
THAT INTO CORRESPONDING RELATIONAL
ALGEBRAIC STATEMENT.  HOWEVER, I MAY
FORGOT ONE THING.  NAMELY, X DOESN'T
EXIST.  IT IS NOT DEFINED AS A RELATION.
YOUR PROGRAM SHOULD BE ABLE TO FLAG THIS.
HOW DO YOU KNOW?  YOU CAN KNOW THIS ONLY
IF YOU HAVE DATABASE DEFINITIONS, RIGHT?
DBD.  SO DBD'S WILL TELL YOU HAVE A
RELATION S AND A RELATION S NAME FIELD,
HAVE A STATUS.  NOW FOR THIS PROJECT, WE
WILL ASSUME THE SIMPLEST, NAMELY
EVERYTHING IS GOING TO BE A STRING.  SO
FOR THE DIFFERENT ATTRIBUTES, YOU JUST
SPECIFIED NUMBER OF BYTES OR NUMBER OF
CHARACTERS.  EVERYTHING IS A STRING.  SO,
IF I HAVE DBD, SO I HAVE ONE RELATION
CALLED S, WITH TWO ATTRIBUTES, FIRST ONE
IS NAME 2 THE SECOND IS OF 4.  SO THERE
SHOULD BE A FILE DEFINING DBD AND I'LL
SHOW YOU HOW THE DBD SHOULD BE DEFINED.
     SO YOUR PROGRAM THEN NEEDS TO FIRST
READ IN WHAT?  THE DBD.  YOU READ IN DBD
TO SET UP THE TABLES, THEN WHEN YOU PASS
THE QUERY -- PARSE THE QUERY YOU CAN CHECK
THE DBD TO KNOW WHETHER THE RELATIONS
EXIST, WHETHER THE ATTRIBUTE NAMES EXIST.
SO, I DON'T WANT YOU TO DAY LOT OF
SEMANTIC CHECKING BUT AT LEAST YOU CAN DO
THIS, CHECK THE EXISTENCE OR NONEXISTENCE
OF RELATIONAL TABLES, CHECK EXISTENCE OF
EACH ATTRIBUTE.  SO THAT'S THE SEMANTIC
PART.  IN OTHER WORDS, YOU CAN DO NOT ONLY
SYNTACTIC CHECKING BUT ALSO SEMANTIC
CHECKING.  THIS REQUIRES INPUT THE
DATABASE DEFINITION.
     SO HERE IS HOW YOUR PROGRAM SHOULD
WORK.  SO, WE'RE RUNNING A PROGRAM.  WELL,
IF YOU'RE IN THE WINDOW, MAYBE A WINDOW
WILL POP UP WHATEVER, THEN FIRST YOU WILL
ASK FOR THIS.  YOU WILL ASK, PROMPT USER
TO ENTER DBD NAME.  THAT'S THE FILE NAME
WHERE YOU STORED THE DATABASE DEFINITION.
SO THE USER WILL TYPE SOMETHING LIKE X.DBD
OR SOMETHING.  OR YOU CAN DEFAULT IT, YOU
CAN DEFAULT AND ALWAYS PICK IT UP FROM
SOMEPLACE, SOME FILE, OKAY, BUT THEN WHEN
THAT TEST -- WHEN I TEST YOUR PROGRAM I
WILL TRY TO MESS THINGS UP.  I WILL EDIT
YOUR DBD FILE, CHANGE THE FILE NAME, STUFF
LIKE THAT, THEN I CAN OBSERVE HOW YOUR
PROGRAM WORKS.  BECAUSE SOMETIMES THE
PROGRAM WORKS ONLY ONE WAY.  I REMEMBER
ONE STUDENT, HE THOUGHT HE WAS CLEVER, HIS
PROGRAM EXPECT TO READ IN QUERY, NEVER
PROCESS THAT, JUST GENERATE A CORRECT
OUTPUT.  BUT ONCE I CHANGED THE DBD, IT
STILL PRODUCED SAME OUTPUT I KNOW
SOMETHING'S WRONG.  THIS IS THE KIND 6
THING.
     SO FIRST ENTER DBD NAME.  AND THEN
YOU CAN ENTER THE NAME OF THE QUERY FILE.
SO LET'S SAY STORE IN Q1.TXT.  SO WE PICK
UP THE QUERY FROM THAT FILE.  IF YOUR
PROGRAM IS FRIENDLY IT SHOULD ALWAYS
REPEAT, DISPLAY THIS QUERY, OTHERWISE
NOBODY CAN SEE IT.  THAT'S KIND OF
AWKWARD.  AND THEN YOU SHOW THE
TRANSLATION.
     THEN YOU ASK WHERE YOU WANT -- WHERE
TO STORE THE TRANSLATED QUERY.  MAYBE
T1.TXT.  SO I CAN PICK THE NAMES.  AND
THEN YOU ASK MORE?  SO IF I SAY YES, I GO
BACK HERE, REPEAT THE SAME THING, NO, WE
EXIT.  SO TYPICALLY YOU PROVIDE MAYBE SIX
OR SEVEN QUERIES, SOME ARE SYNTACTICALLY,
SOME ARE INCORRECT, SOAR SEMANTIC
INCORRECT, THEN YOU CAN TEST THOSE QUERIES
FOR ME.
     SO, GOING BACK, IF YOU CAN DO ALL OF
THIS NICELY IN PERL I HAVE NO PROBLEM.
     STUDENT:   CAN WE DO UNIX INSTEAD OF
WINDOWS.
     PROFESSOR:   EVEN MS-DOS PROMPT,
WHATEVER.  IT SHOULD BE REASONABLY NICE SO
IT'S A CLEAN PROGRAM.
     STUDENT:   SO THERE IS NO REASON TO
INTERFACE IT WITH ORACLE AT ALL?
     PROFESSOR:   NO, NO YOU'RE GOING TO
DO EVERYTHING, YOU ARE DEVELOPING A
MINIATURE OF, MUCH SIMPLIFIED ORACLE.
     STUDENT:   I MEAN IT DOESN'T ACTUALLY
RUN A QUERY IT'S A TRANSLATER.
     PROFESSOR:   THAT'S THE BONUS PART.
     STUDENT:   OH.
     PROFESSOR:   THAT'S THE BONUS PART.
ONE THING AT A TIME.  SO THIS IS CLEAR.
TURN OFF THE LIGHT.
     SO BASICALLY YOU HAVE, YOU MUST BE
ABLE TO SHOW ME, OF COURSE, THE SOURCE
PROGRAM, I JUST TAKE A QUICK LOOK, THE
DBD, SOME QUERIES, SOME OUTPUT, OUTPUT, OF
COURSE AFTER WE RUN THE PROGRAM.  YOU HAVE
EXECUTABLE AND JUST IN A ONE PAGE README.
THIS IS USE OF MANUAL.  VERY SIMPLE, JUST
A FEW LINES SAYING HOW WE CAN RUN THIS
PROGRAM.  OKAY?
     NOW LET'S LOOK AT WHAT'S IN THE
DATABASE DEFINITION.  BY THE WAY, ALL OF
THESE ARE ONLINE SO YOU CAN -- I WILL NOT
LOCK IT, SO YOU CAN CONSULT AT ANY TIME.
SO THE DATABASE DEFINITION IS FOR US OR
DATABASE ADMINISTRATOR TO DEFINE THE
SCHEMA AND WE DO IT IN THE MOST LABORIOUS
AND SIMPLEST WAY.  SO IT'S BASICALLY JUST
A FEW LINES OF TEXT.  WHAT'S IN THE PAREN
THESIS ARE MY EXPLANATIONS, IGNORE THAT.
FOR THE FIRST LINE IS NUMBER THREE.  THIS
MEANS THERE ARE THREE RELATIONS IN THIS
DATABASE.
     THE SECOND LINE IS THE NAME OF THE
FIRST RELATION.  THAT'S THE S.  THE
RELATION S HAS THREE ATTRIBUTES.  AND
FIRST ONE IS S NUMBER FOLLOWED BY S
LENGTH.  WE ASSUME EVERYTHING IS A STRING
SO WE HAVE NO TYPING AND S NAME IS 10
FOLLOWED BY THE NAME OF THE NEXT RELATION,
P, SO ON AND SO FORTH.
     STUDENT:   DO WE HAVE TO USE THAT
FORMAT?
     PROFESSOR:   THIS IS THE SIMPLEST I
CAN THINK OF.  IF YOU WANT TO USE THE
OTHER FORMAT HAVE YOU TO PARSE IT.  YOU
WANT TO PARSE IT, THAT'S FINE, BUT PARSING
TAKES TIME.  HERE I'M DOING IT THE
SIMPLEST WAY SO YOU CAN READ IT IN SIMPLE
TABLE.  THAT'S ALL.  QUESTIONS?
     OKAY.  SO, NOW LET'S TALK ABOUT
GRADING.  OKAY.  SO IF YOU DO THIS
PROJECT, YOU'LL BE ABLE TO ACCEPT QUERY
LIKE THIS, THESE ARE SIMPLEST KIND, ONE
CONDITION AND THIS IS MORE COMPLICATED
WITH MULTIPLE CONDITIONS.  AND MULTIPLE
RELATIONS.  SO THE WAY I GRADE THIS.  SIX
POINTS FOR SUCCESSFULLY DOING THE PROGRAM
TO TRANSLATE THE QUERIES.  EVEN IF YOU
JUST DO THE SIMPLEST QUERY, YOU ALREADY
GOT FOUR POINTS.
     ONE POINT TO HANDLE DIFFERENT DBD'S.
LIKE I SAID, YOUR PROGRAM SHOULD AT LEAST
DO SOME SEMANTIC CHECKING SO THAT IF USER
ENTERS A QUERY AND HAS NOTHING TO DO THE
RELATION ATTRIBUTES, OBVIOUSLY WE SHOULD
BE ABLE TO DETECT IT.  SOME STUDENTS TRY
TO DO SOMETHING NEAT AND WHEN THEY PARSE
IT THEY CAN ACTUALLY FLAG THE ERROR AND
PUT OUT ERROR MESSAGES.  ALL OF THAT WILL
BE REWARDED.  SHOULD BE ABLE TO DEAL WITH
DIFFERENT DBD'S AND JOIN QUERIES.  AND
DETECTS SYNTACTIC AND SEMANTIC ERRORS AND
TWO POINTS FOR QUALITY OF PROGRAMMING.
TWO POINTS INCLUDE POINT HALF POINT FOR
QUALITY OF PROGRAMMING, THAT'S VERY
ELUSIVE BUT YOU KNOW IT'S JUST LIKE EATING
A ROTTEN EGG, IF IT'S ROTTEN YOU KNOW WHEN
YOU EAT IT.  WHEN YOU LOOK AT A PROGRAM,
YOU RUN IT, YOU KNOW IT'S A GOOD PROGRAM.
     TRY TO PUT COMMENTS IN THE SOURCE
CODES.  OTHERWISE, LATER ON YOU WILL NOT
BE ABLE TO READ IT.  DISPLAY FORMAT, YOU
KNOW, SHOULD BE PLEASANT AND USER'S MANUAL
IS THAT ONE PAGE README I TALK ABOUT.
THAT'S ALL FOR THE BASIC TEN POINTS.  YES?
     STUDENT:   DID YOU SAY IF YOU CAN
HANDLE DIFFERENT DBD'S?  IF YOU WANT TO
INPUT DBD IN DIFFERENT FORMAT THAN YOU
GAVE IT TO US, WILL YOU GIVE US ONE, WILL
YOU ADJUST IT IT --
     PROFESSOR:   BY DIFFERENT DBD I MEAN
IF I GOOD IN AND CHANGE TO SOMETHING ELSE
YOU CAN STILL READ IT IN.  NOT MEANING --
DIFFERENT FORMAT IS FINE WITH ME.  IT'S IF
I CHANGE RELATION S TO X IT SHOULD NOT BE
ABLE TO TRANSLATE QUERY CORRECTLY, IT
SHOULD FLAG THAT QUERY AS INCORRECT,
THAT'S WHAT I MEAN.  OTHER QUESTIONS?  NOW
THIS PROJECT IS VERY DOABLE AND YOU CAN
EASILY DO A GOOD JOB THAT'S WHY I SAID
THAT IF YOU WANT TO EARN, AND ALSO IF YOU
ARE GOOD PROGRAMMER YOU CAN DO A BEAUTIFUL
JOB.  I HAVE SOMETIMES GET STUDENT PROJECT
THAT I CANNOT BELIEVE THAT THEY DID IT.
YES?
     STUDENT:   WHEN WE STORE ALL OF THE
INFORMATION OFF OF THE DBD, WHY DO WE NEED
TO STORE HOW LONG ITS STRING IS?
     PROFESSOR:   THAT COMES THE SECOND
PART.  NOW IF YOU DON'T WANT TO RUN IT, IF
YOU DON'T WANT TO EXECUTE THE QUERY,
FORGET IT, THAT INFORMATION IS USELESS BUT
SOMEONE ASKED THIS IS JUST A QUERY
INTERPRETER, DOESN'T DO ANYTHING.  SO NOW
THAT'S THE BONUS PART.
     OKAY.  SO THE BONUS PART.  TURN ON
THE LIGHT.  IS THAT YOU FIRST TRANSLATE
THE QUERY, SO WITH THIS YOU CAN ALREADY
TRANSLATE THE QUERY AND PRODUCE AN OUTPUT.
A FILE WHICH CONSISTS OF RELATIONAL
ALGEBRAIC STATEMENTS.  WE ALREADY LEARNED
THAT FOR THE RELATIONAL ALGEBRA, YOU NEED
ONLY THREE OPERATORS.  WHICH THREE?
PROJECT, RESTRICT AND JOIN.  WITH THAT WE
SAY THE SYSTEM IS RELATIONALLY COMPLETE.
IN OTHER WORDS, IT CAN TRANSLATE ANY
QUERIES THAT CAN BE DEALT WITH.  OKAY.  IN
PREDICATE CALCULUS.  SO IN ORDER FOR US TO
IMPLEMENT THE DBMS WE ONLY HAVE TO
IMPLEMENT THESE THREE OPERATORS BUT I'M
GOING GRADE IT IN SUCH A WAY THAT YOU
DON'T HAVE TO IMPLEMENT ALL THREE OF THEM,
BECAUSE THIS MAY BE TOO TIME CONSUMING.
LET'S SAY IF YOU JUST IMPLEMENT THE
PROJECT, WHICH IS THE SIMPLEST, THEN AT
LEAST YOU CAN DEAL WITH A QUERY WHICH
CONSISTS OF ONLY THE PROJECT, LIKE SELECT
NAME FROM S, SOMETHING LIKE THAT.  RIGHT?
OKAY.  AND THE NEXT ONE IS RESTRICT, THE
NEXT ONE ITS JOIN.
     FOR THAT WE NEED TO TALK ABOUT INPUT
NOW.  NOW I NEED TO DRAW THE BLOCK
DIAGRAM.  SO YOUR FIRST PROGRAM, P1 OR
FIRST MODULE WILL ACCEPT AS INPUT THE DBD,
WHICH IS DATABASE DEFINITION AND THEN CAN
ACCEPT AS INPUT THE QUERY, OR SEVERAL
QUERIES AND TRANSLATE THAT INTO THE
RELATIONAL ALGEBRA.  AND YOUR SECOND
PROGRAM THEN CAN TAKE RELATIONAL ALGEBRA
AND THEN ACTUALLY RUN IT AND PRODUCE THE
RESULT.  BUT THIS HAS TO RUN WITH SOME
DATABASE.  OKAY?  SO WE NEED TO SET UP THE
DATABASE NOW.  SO WE NEED TO FIRST INPUT
THE DATABASE.  THAT'S WHY WE NEED THE
LENGTH.  TURN OFF THE LIGHTS NOW.
     OKAY.  SO AGAIN, I'LL GIVE YOU THE
SIMPLEST WAY.  IF YOU WANT TO FORMAT IT
DIFFERENT WAY, THAT'S FINE WITH ME AS
WELL.  SO, I'M GOING TO INPUT FIRST
RELATION S, HOW MANY TUPLES, TWO TUPLES.
AND THEN EACH TUPLE OR EACH RECORD, HAS TO
BE LAID OUT ACCORDING TO WHAT WAS
SPECIFIED.  SO WE SAY THAT FIRST FIELD HAS
LENGTH 2, SECOND FIELD HAS LENGTH 10, NEXT
FIELD HAS LENGTH FIVE, WHATEVER, THEN IT
HAS TO BE LAID OUT THAT WAY.  OKAY.  SO
YOU SEE THIS LITTLE BIT CHALLENGING.  YOUR
FIRST READING YOUR DATABASE SCHEMA
ACCORDING TO THE SCHEMA YOU READ IN THE
INPUT DATA SET UP THE TABLES.  THEN DO
WHATEVER OPERATION REQUIRED TO DO.  IN
FACT, HISTORICALLY, THE FIRST RELATIONAL
DATABASE IMPLEMENTED USED RELATIONAL
ALGEBRAIC APPROACH AND THEY IMPLEMENTED
THESE THREE OPERATORS.
     STUDENT:   SO NULL FIELDS AREN'T
ALLOWED IN THIS DATABASE?
     PROFESSOR:   NO, NO.  THIS MAKE IT
VERY COMPLICATED.  SO LET'S ASSUME INPUT
DATA IS CLEAN.  SO YOU INPUT THIS DATA AND
THEN YOU CAN CREATE SOMETHING LIKE THIS.
NOW PROJECT IS THE EASIEST TO DO.  THE
OTHER TWO TAKES TIME.  OKAY.  SO IF YOU DO
THAT PART, YOU CAN EARN UP TO THREE
POINTS.  IN FACT EVEN IF YOU DO JUST A
PROJECT USUALLY I GIVE YOU 1.5 BECAUSE
THAT IS SOME EFFORT AND IF YOU GET OTHERS
YOU GET MORE POINTS.  FAIR ENOUGH?  YEAH.
THIS IS A FUN PROJECT.  I JUST TELL YOU
SOME STATISTICS FROM THE PAST.  NORMALLY
ABOUT 40 PERCENT OF STUDENTS ELECT THIS
PROJECT, 60 PERCENT ELECT THE WEB BASED
PROJECT.  AND ALSO THIS 40 PERCENT USUALLY
DO BETTER.  BY DOING BETTER, LET ME
DEFINE, THEY GET BETTER SCORE THAN SECOND
GROUP.  BECAUSE IT'S A VERY CLEAN PROJECT
AND IT'S QUITE EASY TO EARN ANYWHERE FROM
12 TO 15 POINTS.
     STUDENT:   IF YOU WERE TO IMPLEMENT
JUST PROJECT AS PART OF THE BONUS WHAT
WOULD YOUR RESULTS LOOK LIKE IF YOU HAD A
JOIN INSIDE THE SELECT.
     PROFESSOR:   YOU WILL NOT PARSE.
SIMPLY DECLARE THAT YOU CANNOT EXECUTE.
     STUDENT:   SO IF WE ALREADY IMPLEMENT
PROJECT IT WOULD ONLY WORK ON --
     PROFESSOR:   RIGHT.
     STUDENT:   AND THEN CAN'T HANDLE IT.
     PROFESSOR:   YEAH.  BASICALLY, IT'S
LIKE A SECOND LANGUAGE, OKAY.  SO YOU JUST
EXECUTE ONE STATEMENT AT A TIME.  WHEN
THERE IS A STATEMENT YOU CAN'T HANDLE YOU
DECLARE FAILURE AT THAT TIME.  ANY OTHER
QUESTIONS?  OKAY.  NOW, WE HAVE --
NORMALLY WE HAVE TWO TEACHING ASSISTANTS,
SO WE DIVIDE NOW.  SO FOR THIS PROJECT,
PROJECT ONE YOU TALK TO THALIS.  HE IS
ALSO INFORMED ALREADY THAT HE IS SUPPOSED
TO CONSULT WITH YOU ON THIS PROJECT.
NEEDLESS TO SAY LILY WILL BE CONSULTANT
FOR THE SECOND PROJECT.  ANY FURTHER
QUESTIONS?  SO LIKE I SAID, IF YOU WANT TO
START, YOU CAN START IMMEDIATELY WITH THIS
PROJECT.  YEAH.  BUT I WILL APPRECIATE YOU
DROPPING ME A LINE, SEND ME E-MAIL SAYING
I HAVE SELECTED THE FIRST PROJECT.  THIS
WAY I KNOW.  DID I RUN OUT OF TIME?  NOT
YET.  SO LET ME GO TO WHAT I REALLY WANT
TO TALK ABOUT.  BUT YOU CAN SEND ME
E-MAIL, ASK QUESTIONS AS WELL.  AND YOU
CAN USE ANY LANGUAGE THAT YOU ARE
COMFORTABLE WITH.
     STUDENT:   QUESTION.
     PROFESSOR:   YES.
     STUDENT:   YOUR INPUT DATA, SHOULD
THAT FOLLOW FORMAT OF YOUR DATABASE
DEFINITION?
     PROFESSOR:   AGAIN, I ONLY GIVE YOU
THE SIMPLEST WAY I CAN THINK OF.
     STUDENT:   WHAT I'M SAYING IS, HAVE
YOU DEFINITION OF YOUR DATABASE.  NOW,
WHEN YOU CREATE AN INPUT DATA FILE, SHOULD
THAT FILE MIRROR OF THE DEFINITION?
     PROFESSOR:   YES, OF COURSE.
     STUDENT:   THE DEFINITION ASKS FOR
HOW MANY ATTRIBUTES --
     PROFESSOR:   YES, HAVE YOU TO.  YOU
SEE, I HAVE -- I HAVE TO USE FIXED FORMAT.
LET'S SAY I HAVE ATTRIBUTES, K1, K2, K3 IN
MY DEFINITION, THIS IS LENGTH ONE, TWO,
THREE THEN MY INPUT IS LIKE, IN OLD DAYS
WE CALL CART IMAGE.  THIS IS XXY, ZZZ.
HAS TO LOOK LIKE THAT. AND YOU KNOW THIS
IS NOT TRUE.  YOU KNOW IT WILL BE BETTER
PRACTICE IF YOU CAN USE SOMETHING TO
SEPARATE THEM.  THEN YOU CAN GO COMMA,
COMMA.  THAT'S WHAT DAN WAS ASKING IF
THERE WAS NULL VALUES.  WE DON'T ALLOW
THAT.
     STUDENT:   SO THE EXAMPLE YOU GAVE
FOR DEFINITION AND INPUT DATA FILE,
THEY'RE NOT RELATED BECAUSE THE INPUT DATA
FILE DOESN'T HAVE ALL THE FIELDS THAT
DEFINITION DID.
     PROFESSOR:   RIGHT.
     STUDENT:   THAT'S WHAT THREW ME OFF.
     PROFESSOR:   THAT'S THE OPTIONAL
PART.  YOU DON'T HAVE TO DO THAT.

OKAY.  SO TODAY
I EXPLAIN TO YOU THE FIRST PROJECT. 
THE SECOND ONE WILL
BE EXPLAINED IN THE NEXT LECTURE.  IF YOU WANT TO START YOU
CAN ALREADY START IT NOW.

<title>HIERARCHICAL DATABASE MODEL</title>

<h1>HIERARCHICAL DATABASE MODEL</h1>
<h2>Hierarchy is based on Parent-Child Relationship</h2>
<li> Parent-Child Relationship Type
     is basically 1:N relationship
<br>
<li> The schema for a hierarchy has a single root
<br>
<li> To represent M:N relationship
     in a hierarchical structure,
     we must allow duplication of
     child record instances.
<hr>
<h1>HIERARCHICAL OCCURENCE TREE</h1>

The main concepts are:<br>
<br>
     Type indicators such as D, E, W. etc.<br>
     Descendent of a node<br>
     Subtree of a node<br>
     Level (0, 1, 2, etc.)<br>
     Hierarchical sequence<br>
       (used to linearize a tree)<br>
     Complete hierarchical path<br>
       (from root to a leaf)<br>
     Child pointer<br>
     Parent pointer<br>
     Twin pointer (sibling pointer)<br>
<p>
For example, the following is the hierarchical schema of a company database:
<br><IMG SRC="images/fig141.gif"><br>
<p>
The tree representation of the above hierarchical schema is shown below:
<br><IMG SRC="images/fig142.gif"><br>
<p>
The two occurrences of the PCR type (DEPARTMENT and EMPLOYEE) are shown
in (a), and the two occcurrences of the PCR type (DEPARTMENT and PROJECT)
are shown in (b).
<br><IMG SRC="images/fig143.gif"><br>
<hr>
<h1>HIERARCHICAL SEQUENCE</h1>
The hierarchical schema for part of the COMPANY database is as shown:
<br><IMG SRC="images/fig144.gif"><br>
<p>
The hierarchical occurrence tree of the hierarchical schema is as shown:
<br><IMG SRC="images/fig145.gif"><br>
<p>
The hierarchical sequence for the occurrence tree is as shown:
<br><IMG SRC="images/fig146.gif"><br>
<hr>
<h1>VIRTUAL PARENT-CHILD RELATIONSHIPS</h1>
<li> Used to overcome limitations in the
     hierarchical model
<br>
<li> IMS's LDBR type follows this concept
<br>
<li> Gain in flexibility, loss in the
     complexity (almost a network model)
<br><IMG SRC="images/fig147.gif"><br>
<hr>
<h1>IMS CONCEPTS</h1>
     PDBR type
<br>
     Use DBD to specify PDBR type
<br>
     PDBR occurrence
<br>
     LDBR type
<br>
     DBD, PSB and PCB
<br>
     Storage organization
<br>
     How an application invokes IMS
<hr>
<h1>IMS DATABASE EXAMPLE</h1>
The PDBR type is as shown:
<br><IMG SRC="images/fig148.gif"><br>
<p>
The LDBR type is as shown:
<br><IMG SRC="images/fig149.gif"><br>

To specify PDBR type, the DBD statements may look like:

<pre>
1 DBD NAME=EDUCPDBD
2 SEGM NAME=COURSE,BYTES=256
3 FIELD NAME=(COURSE#,SEQ),BYTES=3,START=1
4 FIELD NAME=TITLE,BYTES=33,START=4
5 FIELD NAME=DESCRIPTN,BYTES=220,START=37
6 SEGM NAME=PREREQ,PARENT=COURSE,BYTES=36
7 FIELD NAME=(COURSE#,SEQ),BYTES=3,START=1
8 FIELD NAME=TITLE,BYTES=33,START=4
 .....
</pre>

To specify LDBR type, the DBD statements may look like:

<pre>
1 PCB TYPE=DB.DBNAME=EDUCPDBD,KEYLEN=15
2 SENSEG NAME=COURSE.PROOPT=G
3 SENSEG NAME=OFFERING,PARENT=COURSE.PROOPT=G
4 NAME=STUDENT,PARENT=OFFERING,PROOPT=G
</pre>
<hr>
<h1>IMS QUERY EXAMPLES</h1>

(1) To retrieve the first occurrence of segment OFFERING whose
location is 'MADRID', we can use GET UNIQUE command,
<br>
<br>
GU COURSE<br>
   OFFERING (LOCATION='MADRID')
<br>
<br>
Where (LOCATION='MADRID')
is called the SEGMENT SEARCH ARGUMENT (SSA)
<br><br>
(2) To retrieve all the STUDENT segments for the COURSE OFFERING
in Madrid, we can use GET UNIQUE to get first segment, and GET NEXT  to
retrieve subsequent segments.
<br>
<br>
        GU COURSE<br>
           OFFERING (LOCATION='MADRID')<br>
           STUDENT<br>
    NS  GN STUDENT<br>
        (This loop is terminated on segment not found)<br>
        GO TO NS<br>
<hr>
<h1>IMS QUERY EXAMPLES</h1>
(3) Similarly, to retrieve only grade 'A' students for course
offering in Madrid, we can add an SSA on STUDENT segment,
<br>
<br>
         GU COURSE<br>
            OFFERING (LOCATION='MADRID')<br>
     NS  GN STUDENT (GRADE='A')<br>
         (This loop is terminated on segment not found)<br>
         GO TO NS
<br>
<br>
(4) When no segment name is specified, GET NEXT can be used to
retrieve all segments.
<br>
<br>
         GU COURSE<br>
    NS   GN<br>
         (This loop is terminated when all segments are retrieved)<br>
         GO TO NS
<hr>
<h1>IMS QUERY EXAMPLES</h1>

(5) To retrieve all child segments within a parent segment, we can
use GET NEXT WITHIN PARENT.
<br>
<br>
         GU COURSE (COURSE#='M23')<br>
            OFFERING (DATE='730813')<br>
     NS  GNP STUDENT<br>
         (This loop is terminated when all STUDENT segments
          under same OFFERING segment are retrieved)<br>
         GO TO NS
<br>
<br>
(6) Similarly, we can retrieve all segments within a root segment,
as follows.
<br>
<br>
          GU COURSE (COURSE#='M23')<br>
      NS  GNP<br>
          (This loop is terminated when all segments under
           root segment are retrieved)<br>
          GO TO NS
<hr>
<h1>IMS QUERY EXAMPLES</h1>

(7) To perform insertion of a new segment, the new segment must be
present in I/O work area.  Then the insertion command can be issued.
<br>
<br>
           ISRT COURSE (COURSE#='M23')<br>
                OFFERING (DATE='730813')<br>
                STUDENT<br>
<br>
<br>
(8) To delete a segment, the command GET HOLD is used to "hold" a
segment in work area, and then the DLET command can be issued.
<br>
<br>
           GHU  COURSE (COURSE#='M23')<br>
                OFFERING (DATE='730813')<br>
           DLET
<br><br>
(9) Similar commands are used for segment update.
<br>
           GHU  COURSE (COURSE#='M23')<br>
                OFFERING (DATE='730813')<br>
           (updated segment is in I/O work area)<br>
           REPL<br>
<hr>
<h1>MUMPS</h1>

<li> widely used in the hospitals
<br>
<li> started as an interpretative system
<br>
<li> Key concepts:
<br>
     Segment<br>
     Pointers<br>
     Dynamic data structure<br>
<p>
The MUMPS database has the following hierarchical schema.
<br><IMG SRC="images/fig14a.gif"><br>
<p>
The MUMPS database structure is as follows:
<pre>
*1 drugrecord
 *2 patient
   3 patient-number
   3 name
   3 prescription-date
     4 treated-problem
      *5 drugs-prescribed
        6 drug-name
        6 quantity
        6 frequency
</pre>
In implementation, the MUMPS database structure looks like this:
<br><IMG SRC="images/fig14b.gif"><br>
<hr>
<h1>MUMPS DBML</h1>

To create the drug database structure using segments,
we can use 'set' commands to assign values to global variables,
which are denoted by |xyz.  The first command assigns the name 'drug' to
the directory entry for the drg database.
<br>
<br>
set |drg = 'drug'
<br>
<br>
Similarly, we create the next-level segment by,
<br>
<br>
set |drg(pat) = 'Doe'
<br>
<br>
where 'pat' is a unique numeric key, the patient-number, for patient whose name is 'Doe'.
In MUMPS, all keys must be numeric keys.
<br>
<br>
The subscripts for a global variable, therefore, indicates segments at different
levels.
levels.  Therefore, no previous declaration of file is necessary.
<br>
<br>
To create the next-level segment, we could execute,
<br>
<br>
set |drg(pat,date) = '1203'
<br>
<br>
However, since no data will be stored at this level, this is
unnecessary.  The value for 'date' can be regarded as a numeric key.  Therefore,
we can proceed to the next level to execute,
<br>
<br>
set |drg(pat,date,icd) = 'Asthma'
<br>
<br>
which will also assign a numeric value to 'date'.
<hr>
<h1>MUMPS DBML</h1>

Similarly, we can regard 'dno' (drug-number) as a numeric key, and proceed
to the last level,
<br>
<br>
set |drg(pat,date,icd,dno,1) = 'Decadron'<br>
set |drg(pat,date,icd,dno,2) = 15<br>
set |drg(pat,date,icd,dno,3) = 3<br>
<br>
<br>
To retrieve drug data, we have available as keys patient-number (pat),
prescription-date (date), problem-number (icd), and drug-number (dno).
All keys are numeric subscripts of the global variable 'drg'.  Therefore,
the fetch command is,
<br>
<br>
set drugname = |drg(pat,day,icd,dno,1)
<br>
<br>
The retrieval of a segment is achieved by a sequential scan of segments at
every level, until a match is found.
<br>
<br>
MUMPS implementation normally uses chains of blocks.  Segments at each level
are packed into a chain of blocks and accessed sequentially.
<br>
<br>
To remove a record and release storage, we can execute,
<br>
<br>
kill |drg(pat)
<br>
<br>
which will delete one patient's related segments, by removing
unused blocks and returning freed blocks to free-space chains.
